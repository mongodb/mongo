/**
 * Verifies that when missing, config.placementHistory gets created upon the first historical targeting request received through _configsvrGetHistoricalPlacementInfo command).
 *
 * @tags: [
 *   featureFlagChangeStreamPreciseShardTargeting,
 * ]
 */

import {ShardingTest} from "jstests/libs/shardingtest.js";

function comparePlacementChangeDocuments(docBefore, docAfter) {
    assert.neq(docBefore._id, docAfter._id, "Placement change documents should have different _id values");
    let strippedDocBefore = Object.assign({}, docBefore);
    delete strippedDocBefore._id;
    let strippedDocAfter = Object.assign({}, docAfter);
    delete strippedDocAfter._id;
    assert.docEq(
        strippedDocBefore,
        strippedDocAfter,
        "Placement change documents should have identical metadata on namespace identifiers, commit time and shard distribution",
    );
}
const st = new ShardingTest({shards: 2, config: 1, rs: {nodes: 1}});

const configDB = st.s.getDB("config");
const configRSPrimary = st.configRS.getPrimary();

const testDBName = "testDB";
const testCollName = "testColl";
const testNss = testDBName + "." + testCollName;
const initializationMetadataIdentifier = "";

// Drop config.placement history as a way to simulate a newly spawned cluster (or a cluster that went through an automated restore procedure).
assert.commandWorked(configRSPrimary.getDB("config").runCommand({drop: "placementHistory"}));

// The commit of a DDL operations inserts the expected placement changes but no initialization metadata.
assert.commandWorked(st.s.adminCommand({shardCollection: testNss, key: {_id: 1}}));
assert.eq(
    configDB.placementHistory.countDocuments({nss: testNss}),
    1,
    "Only one placement change doc should be present",
);
const collPlacementChangeDocBeforeTargetingRequest = configDB.placementHistory.findOne({nss: testNss});
assert.eq(
    configDB.placementHistory.countDocuments({nss: testDBName}),
    1,
    "Only one placement change doc should be present",
);
const dbPlacementChangeDocBeforeTargetingRequest = configDB.placementHistory.findOne({nss: testDBName});
assert.eq(
    configDB.placementHistory.countDocuments({identifier: initializationMetadataIdentifier}),
    0,
    "No initialization metadata should be present",
);

// The first targeting request should synchronously trigger the lazy initialization of the placement history metadata before being processed.
const dawnOfTime = Timestamp(0, 1);
const atTargetingRequestTime = configDB.hello().$clusterTime.clusterTime;
const targetingResponse = assert.commandWorked(
    configRSPrimary.adminCommand({
        _configsvrGetHistoricalPlacement: testNss,
        at: atTargetingRequestTime,
        ignoreRemovedShards: false,
        checkIfPointInTimeIsInFuture: false,
    }),
);

const initializationMetadataDocsAfterFirstTargetingRequest = configDB.placementHistory
    .find({nss: initializationMetadataIdentifier})
    .sort({timestamp: 1})
    .toArray();
assert.eq(
    initializationMetadataDocsAfterFirstTargetingRequest.length,
    2,
    "Initialization metadata should have been lazily created after targeting request",
);
const dawnOfTimeMetadataDoc = initializationMetadataDocsAfterFirstTargetingRequest[0];
const initializationTimeMetadataDoc = initializationMetadataDocsAfterFirstTargetingRequest[1];
assert(timestampCmp(dawnOfTimeMetadataDoc.timestamp, dawnOfTime) === 0);
assert(timestampCmp(initializationTimeMetadataDoc.timestamp, atTargetingRequestTime) > 0);

// Since the targeting request references a PIT that predates the creation of the initialization metadata, its response should have been produced using the approximate placement info.
assert.sameMembers(
    targetingResponse.historicalPlacement.shards,
    dawnOfTimeMetadataDoc.shards,
    "Targeting response should use approximate placement info for collection",
);

// For placement change documents generated by a create operation, the information before and after the metadata initialization should be equivalent (but not identical).
assert.eq(
    configDB.placementHistory.countDocuments({nss: testNss}),
    1,
    "Only one placement change doc should be present",
);
const collPlacementChangeDocAfterTargetingRequest = configDB.placementHistory.findOne({nss: testNss});
assert.eq(
    configDB.placementHistory.countDocuments({nss: testDBName}),
    1,
    "Only one placement change doc should be present",
);
const dbPlacementChangeDocAfterTargetingRequest = configDB.placementHistory.findOne({nss: testDBName});
assert.eq(
    configDB.placementHistory.countDocuments({identifier: initializationMetadataIdentifier}),
    0,
    "No initialization metadata should be present",
);

comparePlacementChangeDocuments(
    collPlacementChangeDocBeforeTargetingRequest,
    collPlacementChangeDocAfterTargetingRequest,
);
comparePlacementChangeDocuments(dbPlacementChangeDocBeforeTargetingRequest, dbPlacementChangeDocAfterTargetingRequest);

// A second targeting request should not trigger a new metadata initialization.
const laterAtTargetingRequestTime = configDB.hello().$clusterTime.clusterTime;
assert.commandWorked(
    configRSPrimary.adminCommand({
        _configsvrGetHistoricalPlacement: testNss,
        at: laterAtTargetingRequestTime,
        ignoreRemovedShards: false,
        checkIfPointInTimeIsInFuture: false,
    }),
);
const initializationMetadataDocsAfterSecondTargetingRequest = configDB.placementHistory
    .find({nss: initializationMetadataIdentifier})
    .sort({timestamp: 1})
    .toArray();
assert.sameMembers(
    initializationMetadataDocsAfterFirstTargetingRequest,
    initializationMetadataDocsAfterSecondTargetingRequest,
);

st.stop();
