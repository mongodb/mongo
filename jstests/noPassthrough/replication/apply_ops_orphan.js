/**
 * Verify that applyOps updates and deletes with recordIds work correctly against orphaned documents.
 *
 * @tags: [
 *   requires_sharding,
 * ]
 */
import {FeatureFlagUtil} from "jstests/libs/feature_flag_util.js";
import {ShardingTest} from "jstests/libs/shardingtest.js";

// Deliberately inserts orphans outside of migration.
TestData.skipCheckOrphans = true;

const st = new ShardingTest({shards: 2});
const ns = "test." + jsTestName();
const mongosDB = st.s.getDB("test");
const mongosColl = st.s.getCollection(ns);

let recordIdsReplicated = FeatureFlagUtil.isPresentAndEnabled(mongosDB, "RecordIdsReplicated");

assert.commandWorked(st.s.adminCommand({enableSharding: "test", primaryShard: st.shard1.name}));
assert.commandWorked(mongosDB.createCollection(jsTestName()));
assert.commandWorked(st.s.adminCommand({shardCollection: ns, key: {a: 1, b: 1}, unique: true}));

// shard0 gets chunk so we can create orphans on shard1.
assert.commandWorked(st.s.adminCommand({split: ns, middle: {a: 1, b: 10}}));
assert.commandWorked(st.s.adminCommand({split: ns, middle: {a: 1, b: 20}}));
assert.commandWorked(st.s.adminCommand({moveChunk: ns, find: {a: 1, b: 15}, to: st.shard0.shardName}));

const shard1DB = st.shard1.getDB("test");

// Insert orphan document directly on shard1 using applyOps.
const shard1Coll = st.shard1.getCollection(ns);
const orphanDoc = {
    _id: 1,
    a: 1,
    b: 15,
    value: "orphan",
};
// assert.commandWorked(shard1Coll.insert(orphanDoc));
let insertOp = {
    op: "i",
    ns: ns,
    o: {
        _id: 1,
        a: 1,
        b: 15,
        value: "orphan",
    },
};
const orphanRid = 100;
if (recordIdsReplicated) {
    insertOp["rid"] = orphanRid;
}
assert.commandWorked(shard1DB.runCommand({applyOps: [insertOp]}));

// Get the recordId for the orphan.
const orphanWithRid = shard1Coll.find({_id: 1}).showRecordId().toArray()[0];
if (recordIdsReplicated) {
    assert.eq(orphanRid, orphanWithRid.$recordId);
}

// Verify mongos doesn't see the orphan.
assert.eq(mongosColl.find().itcount(), 0);

let updateOp = {
    op: "u",
    ns: ns,
    o: {$v: 2, diff: {u: {value: "updated"}}},
    o2: {_id: 1},
};

let deleteOp = {
    op: "d",
    ns: ns,
    o: {_id: 1},
    o2: {_id: 1},
};

if (recordIdsReplicated) {
    updateOp["rid"] = orphanRid;
    deleteOp["rid"] = orphanRid;
}

assert.commandWorked(shard1DB.runCommand({applyOps: [updateOp]}));
assert.eq(shard1Coll.findOne({_id: 1}).value, "updated");

// Test 2: applyOps delete on orphan.
assert.commandWorked(shard1DB.runCommand({applyOps: [deleteOp]}));
assert.eq(shard1Coll.count({_id: 1}), 0);

// Verify that fromMigrate:true is set on the oplog entries generated by the applyOps writes.
st.rs1.awaitReplication();
let shard1Oplog = st.rs1.getPrimary().getDB("local").oplog.rs;

const oplogEntries = shard1Oplog.find({"ns": ns}).toArray();
assert.eq(shard1Oplog.find({"ns": ns, "op": "i", "o._id": 1, "fromMigrate": true}).toArray().length, 1, oplogEntries);
assert.eq(shard1Oplog.find({"ns": ns, "op": "u", "o2._id": 1, "fromMigrate": true}).toArray().length, 1, oplogEntries);
assert.eq(shard1Oplog.find({"ns": ns, "op": "d", "o._id": 1, "fromMigrate": true}).toArray().length, 1, oplogEntries);

st.stop();
