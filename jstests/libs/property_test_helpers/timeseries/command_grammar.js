/*
 * Grammar for commands generated by timeseries PBT tests.
 * This defines the shape of commands, they are generated by arbitraries
 * defined in command_arbitraries.js. These are intended to define a general
 * framework so that arbitraries can generate abstract commands for the
 * test harness to run against both time-series and control collections.
 */

/**
 * The model is used to track the expected contents of the collections, to enable
 * delete/update commands to pick valid targets, and to check preconditions.
 *
 * Model shape:
 *   { docs: Map<string, doc> }
 */
export function makeEmptyModel() {
    return {docs: new Map()};
}

export function modelHasDoc(model, id) {
    return model.docs.has(String(id));
}

export function modelInsert(model, doc) {
    model.docs.set(String(doc._id), doc);
}

export function modelInsertMany(model, docs) {
    for (const doc of docs) {
        modelInsert(model, doc);
    }
}

export function modelDeleteById(model, id) {
    model.docs.delete(String(id));
}

/**
 * A "stable" pick: returns some doc (the first in insertion/iteration order)
 * or null if the model is empty. Useful for commands that want a consistent
 * target instead of random choice.
 */
export function pickStableDoc(model) {
    const it = model.docs.values().next();
    return it.done ? null : it.value;
}

/**
 * Helper: get all _ids from the model (as strings).
 */
function getAllIdsFromModel(model) {
    if (!model || !(model.docs instanceof Map)) {
        return [];
    }
    return Array.from(model.docs.keys());
}

/**
 * InsertCommand: single doc insert.
 *
 * Expects `model` to be {docs: Map<string, doc>}.
 */
export class InsertCommand {
    constructor(doc) {
        this.doc = doc;
    }

    toString() {
        return `InsertCommand(_id=${this.doc._id})`;
    }

    /**
     * No preconditions.
     */
    check(model) {}

    /**
     * Run against both tsColl and ctrlColl, and update the model.
     */
    run(model, colls) {
        const {tsColl, ctrlColl} = colls;

        const resTs = tsColl.insertOne(this.doc);
        if (resTs && resTs.acknowledged === false) {
            throw new Error("Insert into tsColl failed");
        }

        const resCtrl = ctrlColl.insertOne(this.doc);
        if (resCtrl && resCtrl.acknowledged === false) {
            throw new Error("Insert into ctrlColl failed");
        }

        modelInsert(model, this.doc);
    }
}

/**
 * BatchInsertCommand: insert an array of docs in one batch.
 */
export class BatchInsertCommand {
    constructor(docs) {
        this.docs = docs;
    }

    toString() {
        const ids = this.docs.map((d) => d._id).join(",");
        return `BatchInsertCommand(count=${this.docs.length}, _ids=[${ids}])`;
    }

    /**
     * Precondition:
     *  - docs array is non-empty
     */
    check(model) {
        return Array.isArray(this.docs) && this.docs.length > 0;
    }

    /**
     * Run against both tsColl and ctrlColl, and update the model.
     */
    run(model, colls) {
        const {tsColl, ctrlColl} = colls;

        if (!this.docs || this.docs.length === 0) {
            return;
        }

        const resTs = tsColl.insertMany(this.docs);
        if (resTs && resTs.acknowledged === false) {
            throw new Error("Batch insert into tsColl failed");
        }

        const resCtrl = ctrlColl.insertMany(this.docs);
        if (resCtrl && resCtrl.acknowledged === false) {
            throw new Error("Batch insert into ctrlColl failed");
        }

        // Use the helper that understands the Map-shaped model.
        modelInsertMany(model, this.docs);
    }
}

/**
 * DeleteByRandomIdCommand: delete a randomly chosen doc by _id.
 *
 * The specific _id is chosen *at run time* from the model, not passed in.
 */
export class DeleteByRandomIdCommand {
    constructor() {
        // Chosen _id is determined lazily during run; we keep it for logging.
        this._id = undefined;
    }

    toString() {
        const idStr = this._id !== undefined ? this._id : "<unselected>";
        return `DeleteByRandomIdCommand(_id=${idStr})`;
    }

    /**
     * Precondition: there must be at least one doc in the model to delete.
     */
    check(model) {
        const ids = getAllIdsFromModel(model);
        return ids.length > 0;
    }

    /**
     * Pick a random _id from the model, delete it from both collections,
     * then update the model.
     */
    run(model, colls) {
        const {tsColl, ctrlColl} = colls;

        const ids = getAllIdsFromModel(model);
        if (ids.length === 0) {
            throw new Error("DeleteByRandomIdCommand.run called with empty model");
        }

        const idx = Math.floor(Math.random() * ids.length);
        const chosenId = ids[idx];
        this._id = chosenId; // save for logging/debugging

        const resTs = tsColl.deleteOne({_id: chosenId});
        if (resTs && resTs.acknowledged === false) {
            throw new Error("Delete from tsColl failed");
        }

        const resCtrl = ctrlColl.deleteOne({_id: chosenId});
        if (resCtrl && resCtrl.acknowledged === false) {
            throw new Error("Delete from ctrlColl failed");
        }

        modelDeleteById(model, chosenId);
    }
}
