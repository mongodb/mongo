# Configures the build to use the GCC toolchain in /opt/mongodbtoolchain/v4

import os
import subprocess
import platform
import SCons.Defaults
from SCons.Script import ARGUMENTS

if not ARGUMENTS.get('CC') and not ARGUMENTS.get("CXX") and platform.machine() != "s390x":

   
   toolchain_exec_root = SCons.Script.Main.GetOption('toolchain-root')
   toolchain_root = toolchain_exec_root + "/external/mongo_toolchain/v4"
   local_toolchain_root = '/opt/mongodbtoolchain/v4'
   if not toolchain_root:
      toolchain_root = local_toolchain_root

   toolchain_bindir = os.path.join(toolchain_root, 'bin')
   local_toolchain_bindir = os.path.join(local_toolchain_root, 'bin')

   # Get the default SCons path as a list
   default_path = SCons.Defaults.DefaultEnvironment()['ENV']['PATH'].split(os.pathsep)
   exec(open('bazel/toolchains/mongo_toolchain_flags.bzl', "rb").read())
   arch = ARCH_NORMALIZE_MAP[platform.machine()]
  
   # Put the toolchain path first so we prefer all tools from there in subprocs
   ENV = {
      'PATH' : os.pathsep.join([toolchain_bindir, local_toolchain_bindir] + default_path)
   }
   TOOLCHAIN_LINKFLAGS=[]
   for flag in COMMON_LINK_FLAGS:
      TOOLCHAIN_LINKFLAGS.append("-L"+toolchain_exec_root+"/"+flag.format(arch=arch))
   TOOLCHAIN_CCFLAGS = ["-nostdinc++"]
   for flag in CLANG_INCLUDE_DIRS+COMMON_INCLUDE_DIRECTORIES+COMMON_BUILTIN_INCLUDE_DIRECTORIES:
      if flag.startswith("/"):
         TOOLCHAIN_CCFLAGS.append("-isystem"+flag.format(arch=arch))
      else:
         TOOLCHAIN_CCFLAGS.append("-isystem"+toolchain_exec_root+"/"+flag.format(arch=arch))
   
   # TODO BUILD-16594
   # This is temporary workaround so that gcc can find the LLVM lld from the toolchain
   # until we can build this into the toolchain's default search paths
   LINKFLAGS_COMPILER_EXEC_PREFIX = [f'{toolchain_bindir}']
   for flag in COMMON_BINDIRS:
      LINKFLAGS_COMPILER_EXEC_PREFIX.append(toolchain_exec_root+"/"+flag.format(arch=arch))

   # Set any Variables for Tools from the toolchain here. Technically, we
   # shouldn't need the full paths since SCons will find the toolchain
   # ones first, but we don't want to accidentally get the system version
   # if, say, the toolchain is missing. Also, it is clearer that we are
   # getting the right toolchain in build log output when the path is
   # printed for each compiler invocation.

   CC = os.path.join(toolchain_bindir, 'clang')
   CXX = os.path.join(toolchain_bindir, 'clang++')
   DWP = os.path.join(local_toolchain_bindir, 'dwp')
   READELF = os.path.join(local_toolchain_bindir, 'readelf')
   GDB = os.path.join(local_toolchain_bindir, 'gdb')
   
   bazel_toolchain_bin = SCons.Script.Main.GetOption('bazel-toolchain-clang')
   if bazel_toolchain_bin:
      cxx_realpath = os.path.join(bazel_toolchain_bin, "clang++")
   else:
      cxx_realpath = CXX
   
   try:
      AR = subprocess.check_output([cxx_realpath, '-print-prog-name=ar']).decode('utf-8').strip()
      AS = subprocess.check_output([cxx_realpath, '-print-prog-name=as']).decode('utf-8').strip()
      OBJCOPY = subprocess.check_output([cxx_realpath, '-print-prog-name=objcopy']).decode('utf-8').strip()
      LLVM_SYMBOLIZER = subprocess.check_output([cxx_realpath, '-print-prog-name=llvm-symbolizer']).decode('utf-8').strip()
   except subprocess.CalledProcessError as e:
      print("Failed while invoking toolchain binary " + cxx_realpath + ": " + str(e.output))
      SCons.Script.Exit(-1)
   except OSError as e:
      print("Failed to invoke toolchain binary " + cxx_realpath + ": " + str(e))
      SCons.Script.Exit(-1)

   DWARF_VERSION=4
