/**
 *    Copyright (C) 2018-present MongoDB, Inc.
 *
 *    This program is free software: you can redistribute it and/or modify
 *    it under the terms of the Server Side Public License, version 1,
 *    as published by MongoDB, Inc.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    Server Side Public License for more details.
 *
 *    You should have received a copy of the Server Side Public License
 *    along with this program. If not, see
 *    <http://www.mongodb.com/licensing/server-side-public-license>.
 *
 *    As a special exception, the copyright holders give permission to link the
 *    code of portions of this program with the OpenSSL library under certain
 *    conditions as described in each individual source file and distribute
 *    linked combinations including the program with the OpenSSL library. You
 *    must comply with the Server Side Public License in all respects for
 *    all of the code used other than as permitted herein. If you modify file(s)
 *    with this exception, you may extend this exception to your version of the
 *    file(s), but you are not obligated to do so. If you do not wish to do so,
 *    delete this exception statement from your version. If you delete this
 *    exception statement from all source files in the program, then also delete
 *    it in the license file.
 */

#include "mongo/platform/basic.h"

#include "mongo/db/matcher/doc_validation_error.h"
#include "mongo/db/matcher/expression_parser.h"
#include "mongo/db/pipeline/expression_context_for_test.h"
#include "mongo/unittest/unittest.h"

namespace mongo {
namespace {
/**
 * Utility function which parses a MatchExpression from 'query' and verifies that the error
 * generated by the parsed MatchExpression and 'document' matches 'expectedError'.
 */
void verifyGeneratedError(BSONObj query, BSONObj document, BSONObj expectedError) {
    boost::intrusive_ptr<ExpressionContextForTest> expCtx(new ExpressionContextForTest());
    expCtx->isParsingCollectionValidator = true;
    StatusWithMatchExpression result = MatchExpressionParser::parse(query, expCtx);
    ASSERT_OK(result.getStatus());
    MatchExpression* expr = result.getValue().get();
    BSONObj generatedError = doc_validation_error::generateError(*expr, document);
    ASSERT_BSONOBJ_EQ(generatedError, expectedError);
}

// Comparison operators.
// $eq
TEST(ComparisonMatchExpression, BasicEq) {
    BSONObj query = BSON("a" << BSON("$eq" << 2));
    BSONObj document = BSON("a" << 1);
    BSONObj expectedError = BSON("operatorName"
                                 << "$eq"
                                 << "specifiedAs" << query << "reason"
                                 << "comparison failed"
                                 << "consideredValue" << 1);
    verifyGeneratedError(query, document, expectedError);
}

TEST(ComparisonMatchExpression, EqMissingPath) {
    BSONObj query = BSON("a" << BSON("$eq" << 2));
    BSONObj document = BSON("b" << 1);
    BSONObj expectedError = BSON("operatorName"
                                 << "$eq"
                                 << "specifiedAs" << query << "reason"
                                 << "field was missing");
    verifyGeneratedError(query, document, expectedError);
}

TEST(ComparisonMatchExpression, EqImplicitArrayTraversal) {
    BSONObj query = BSON("a" << BSON("$eq" << 2));
    BSONObj document = BSON("a" << BSON_ARRAY(3 << 4 << 5));
    BSONObj expectedError = BSON("operatorName"
                                 << "$eq"
                                 << "specifiedAs" << query << "reason"
                                 << "comparison failed"
                                 << "consideredValues"
                                 << BSON_ARRAY(3 << 4 << 5 << BSON_ARRAY(3 << 4 << 5)));
    verifyGeneratedError(query, document, expectedError);
}

TEST(ComparisonMatchExpression, EqImplicitArrayTraversalNestedDocumentSingleElement) {
    BSONObj query = BSON("a.b" << BSON("$eq" << 2));
    BSONObj document = BSON("a" << BSON_ARRAY(BSON("b" << 3)));
    BSONObj expectedError = BSON("operatorName"
                                 << "$eq"
                                 << "specifiedAs" << query << "reason"
                                 << "comparison failed"
                                 << "consideredValue" << 3);
    verifyGeneratedError(query, document, expectedError);
}

TEST(ComparisonMatchExpression, EqImplicitArrayTraversalNestedDocument) {
    BSONObj query = BSON("a.b" << BSON("$eq" << 2));
    BSONObj document = BSON("a" << BSON_ARRAY(BSON("b" << 3) << BSON("b" << 4) << BSON("b" << 5)));
    BSONObj expectedError = BSON("operatorName"
                                 << "$eq"
                                 << "specifiedAs" << query << "reason"
                                 << "comparison failed"
                                 << "consideredValues" << BSON_ARRAY(3 << 4 << 5));
    verifyGeneratedError(query, document, expectedError);
}

TEST(ComparisonMatchExpression, EqImplicitArrayTraversalNestedArrays) {
    BSONObj query = BSON("a.b" << BSON("$eq" << 0));
    BSONObj document =
        BSON("a" << BSON_ARRAY(BSON("b" << BSON_ARRAY(1 << 2)) << BSON("b" << BSON_ARRAY(3 << 4))));
    BSONObj expectedError = BSON("operatorName"
                                 << "$eq"
                                 << "specifiedAs" << query << "reason"
                                 << "comparison failed"
                                 << "consideredValues"
                                 << BSON_ARRAY(1 << 2 << BSON_ARRAY(1 << 2) << 3 << 4
                                                 << BSON_ARRAY(3 << 4)));
    verifyGeneratedError(query, document, expectedError);
}

TEST(ComparisonMatchExpression, EqNoOperator) {
    BSONObj query = BSON("a" << 2);
    BSONObj document = BSON("a" << 1);
    BSONObj expectedError = BSON("operatorName"
                                 << "$eq"
                                 << "specifiedAs" << query << "reason"
                                 << "comparison failed"
                                 << "consideredValue" << 1);
    verifyGeneratedError(query, document, expectedError);
}

// $ne
TEST(ComparisonMatchExpression, BasicNe) {
    BSONObj query = BSON("a" << BSON("$ne" << 2));
    BSONObj document = BSON("a" << 2);
    BSONObj expectedError = BSON("operatorName"
                                 << "$ne"
                                 << "specifiedAs" << query << "reason"
                                 << "comparison succeeded"
                                 << "consideredValue" << 2);
    verifyGeneratedError(query, document, expectedError);
}

TEST(ComparisonMatchExpression, NeImplicitArrayTraversal) {
    BSONObj query = BSON("a" << BSON("$ne" << 2));
    BSONObj document = BSON("a" << BSON_ARRAY(1 << 2 << 3));
    BSONObj expectedError = BSON("operatorName"
                                 << "$ne"
                                 << "specifiedAs" << query << "reason"
                                 << "comparison succeeded"
                                 << "consideredValues"
                                 << BSON_ARRAY(1 << 2 << 3 << BSON_ARRAY(1 << 2 << 3)));
    verifyGeneratedError(query, document, expectedError);
}

// $lt
TEST(ComparisonMatchExpression, BasicLt) {
    BSONObj query = BSON("a" << BSON("$lt" << 0));
    BSONObj document = BSON("a" << 1);
    BSONObj expectedError = BSON("operatorName"
                                 << "$lt"
                                 << "specifiedAs" << query << "reason"
                                 << "comparison failed"
                                 << "consideredValue" << 1);
    verifyGeneratedError(query, document, expectedError);
}

TEST(ComparisonMatchExpression, LtMissingPath) {
    BSONObj query = BSON("a" << BSON("$lt" << 0));
    BSONObj document = BSON("b" << 1);
    BSONObj expectedError = BSON("operatorName"
                                 << "$lt"
                                 << "specifiedAs" << query << "reason"
                                 << "field was missing");
    verifyGeneratedError(query, document, expectedError);
}

TEST(ComparisonMatchExpression, LtImplicitArrayTraversal) {
    BSONObj query = BSON("a" << BSON("$lt" << 0));
    BSONObj document = BSON("a" << BSON_ARRAY(3 << 4 << 5));
    BSONObj expectedError = BSON("operatorName"
                                 << "$lt"
                                 << "specifiedAs" << query << "reason"
                                 << "comparison failed"
                                 << "consideredValues"
                                 << BSON_ARRAY(3 << 4 << 5 << BSON_ARRAY(3 << 4 << 5)));
    verifyGeneratedError(query, document, expectedError);
}

// $lte
TEST(ComparisonMatchExpression, BasicLte) {
    BSONObj query = BSON("a" << BSON("$lte" << 0));
    BSONObj document = BSON("a" << 1);
    BSONObj expectedError = BSON("operatorName"
                                 << "$lte"
                                 << "specifiedAs" << query << "reason"
                                 << "comparison failed"
                                 << "consideredValue" << 1);
    verifyGeneratedError(query, document, expectedError);
}

TEST(ComparisonMatchExpression, LteMissingPath) {
    BSONObj query = BSON("a" << BSON("$lte" << 0));
    BSONObj document = BSON("b" << 1);
    BSONObj expectedError = BSON("operatorName"
                                 << "$lte"
                                 << "specifiedAs" << query << "reason"
                                 << "field was missing");
    verifyGeneratedError(query, document, expectedError);
}

TEST(ComparisonMatchExpression, LteImplicitArrayTraversal) {
    BSONObj query = BSON("a" << BSON("$lte" << 0));
    BSONObj document = BSON("a" << BSON_ARRAY(3 << 4 << 5));
    BSONObj expectedError = BSON("operatorName"
                                 << "$lte"
                                 << "specifiedAs" << query << "reason"
                                 << "comparison failed"
                                 << "consideredValues"
                                 << BSON_ARRAY(3 << 4 << 5 << BSON_ARRAY(3 << 4 << 5)));
    verifyGeneratedError(query, document, expectedError);
}

// $gt
TEST(ComparisonMatchExpression, BasicGt) {
    BSONObj query = BSON("a" << BSON("$gt" << 3));
    BSONObj document = BSON("a" << 0);
    BSONObj expectedError = BSON("operatorName"
                                 << "$gt"
                                 << "specifiedAs" << query << "reason"
                                 << "comparison failed"
                                 << "consideredValue" << 0);
    verifyGeneratedError(query, document, expectedError);
}

TEST(ComparisonMatchExpression, GtMissingPath) {
    BSONObj query = BSON("a" << BSON("$gt" << 3));
    BSONObj document = BSON("b" << 1);
    BSONObj expectedError = BSON("operatorName"
                                 << "$gt"
                                 << "specifiedAs" << query << "reason"
                                 << "field was missing");
    verifyGeneratedError(query, document, expectedError);
}

TEST(ComparisonMatchExpression, GtImplicitArrayTraversal) {
    BSONObj query = BSON("a" << BSON("$gt" << 3));
    BSONObj document = BSON("a" << BSON_ARRAY(0 << 1 << 2));
    BSONObj expectedError = BSON("operatorName"
                                 << "$gt"
                                 << "specifiedAs" << query << "reason"
                                 << "comparison failed"
                                 << "consideredValues"
                                 << BSON_ARRAY(0 << 1 << 2 << BSON_ARRAY(0 << 1 << 2)));
    verifyGeneratedError(query, document, expectedError);
}

// $gte
TEST(ComparisonMatchExpression, BasicGte) {
    BSONObj query = BSON("a" << BSON("$gte" << 3));
    BSONObj document = BSON("a" << 0);
    BSONObj expectedError = BSON("operatorName"
                                 << "$gte"
                                 << "specifiedAs" << query << "reason"
                                 << "comparison failed"
                                 << "consideredValue" << 0);
    verifyGeneratedError(query, document, expectedError);
}

TEST(ComparisonMatchExpression, GteMissingPath) {
    BSONObj query = BSON("a" << BSON("$gte" << 3));
    BSONObj document = BSON("b" << 1);
    BSONObj expectedError = BSON("operatorName"
                                 << "$gte"
                                 << "specifiedAs" << query << "reason"
                                 << "field was missing");
    verifyGeneratedError(query, document, expectedError);
}

TEST(ComparisonMatchExpression, GteImplicitArrayTraversal) {
    BSONObj query = BSON("a" << BSON("$gte" << 3));
    BSONObj document = BSON("a" << BSON_ARRAY(0 << 1 << 2));
    BSONObj expectedError = BSON("operatorName"
                                 << "$gte"
                                 << "specifiedAs" << query << "reason"
                                 << "comparison failed"
                                 << "consideredValues"
                                 << BSON_ARRAY(0 << 1 << 2 << BSON_ARRAY(0 << 1 << 2)));
    verifyGeneratedError(query, document, expectedError);
}

// $in
TEST(ComparisonMatchExpression, BasicIn) {
    BSONObj query = BSON("a" << BSON("$in" << BSON_ARRAY(1 << 2 << 3)));
    BSONObj document = BSON("a" << 4);
    BSONObj expectedError = BSON("operatorName"
                                 << "$in"
                                 << "specifiedAs" << query << "reason"
                                 << "no matching value found in array"
                                 << "consideredValue" << 4);
    verifyGeneratedError(query, document, expectedError);
}

TEST(ComparisonMatchExpression, InMissingPath) {
    BSONObj query = BSON("a" << BSON("$in" << BSON_ARRAY(1 << 2 << 3)));
    BSONObj document = BSON("b" << 1);
    BSONObj expectedError = BSON("operatorName"
                                 << "$in"
                                 << "specifiedAs" << query << "reason"
                                 << "field was missing");
    verifyGeneratedError(query, document, expectedError);
}

TEST(ComparisonMatchExpression, InNestedDocumentsAndArrays) {
    BSONObj query =
        BSON("a.b" << BSON("$in" << BSON_ARRAY(5 << 6 << 7 << BSON_ARRAY(2 << 3 << 4))));
    BSONObj document =
        BSON("a" << BSON_ARRAY(BSON("b" << BSON_ARRAY(1 << 2)) << BSON("b" << BSON_ARRAY(3 << 4))));
    BSONObj expectedError = BSON("operatorName"
                                 << "$in"
                                 << "specifiedAs" << query << "reason"
                                 << "no matching value found in array"
                                 << "consideredValues"
                                 << BSON_ARRAY(1 << 2 << BSON_ARRAY(1 << 2) << 3 << 4
                                                 << BSON_ARRAY(3 << 4)));
    verifyGeneratedError(query, document, expectedError);
}

// $nin
TEST(ComparisonMatchExpression, BasicNin) {
    BSONObj query = BSON("a" << BSON("$nin" << BSON_ARRAY(1 << 2 << 3)));
    BSONObj document = BSON("a" << 3);
    BSONObj expectedError = BSON("operatorName"
                                 << "$nin"
                                 << "specifiedAs" << query << "reason"
                                 << "matching value found in array"
                                 << "consideredValue" << 3);
    verifyGeneratedError(query, document, expectedError);
}

TEST(ComparisonMatchExpression, NinNestedDocumentsAndArrays) {
    BSONObj query = BSON("a.b" << BSON("$nin" << BSON_ARRAY(1 << BSON_ARRAY(2 << 3 << 4))));
    BSONObj document =
        BSON("a" << BSON_ARRAY(BSON("b" << BSON_ARRAY(1 << 2)) << BSON("b" << BSON_ARRAY(3 << 4))));
    BSONObj expectedError = BSON("operatorName"
                                 << "$nin"
                                 << "specifiedAs" << query << "reason"
                                 << "matching value found in array"
                                 << "consideredValues"
                                 << BSON_ARRAY(1 << 2 << BSON_ARRAY(1 << 2) << 3 << 4
                                                 << BSON_ARRAY(3 << 4)));
    verifyGeneratedError(query, document, expectedError);
}

// Verify that Comparison operators which accept a regex ($in and $nin) work as expected.
TEST(ComparisonMatchExpression, InAcceptsRegex) {
    BSONObj query = BSON(
        "a" << BSON("$in" << BSON_ARRAY(BSONRegEx("^v") << BSONRegEx("^b") << BSONRegEx("^c"))));
    BSONObj document = BSON("a"
                            << "Validation");
    BSONObj expectedError = BSON("operatorName"
                                 << "$in"
                                 << "specifiedAs" << query << "reason"
                                 << "no matching value found in array"
                                 << "consideredValue"
                                 << "Validation");
    verifyGeneratedError(query, document, expectedError);
}

TEST(ComparisonMatchExpression, NinAcceptsRegex) {
    BSONObj query = BSON(
        "a" << BSON("$nin" << BSON_ARRAY(BSONRegEx("^v") << BSONRegEx("^b") << BSONRegEx("^c"))));
    BSONObj document = BSON("a"
                            << "berry");
    BSONObj expectedError = BSON("operatorName"
                                 << "$nin"
                                 << "specifiedAs" << query << "reason"
                                 << "matching value found in array"
                                 << "consideredValue"
                                 << "berry");
    verifyGeneratedError(query, document, expectedError);
}

// Logical operators
// $and
TEST(LogicalMatchExpression, BasicAnd) {
    BSONObj failingClause = BSON("a" << BSON("$lt" << 10));
    BSONObj query = BSON("$and" << BSON_ARRAY(BSON("b" << BSON("$gt" << 0)) << failingClause));
    BSONObj document = BSON("a" << 11 << "b" << 2);
    BSONObj expectedError = BSON("operatorName"
                                 << "$and"
                                 << "clausesNotSatisfied"
                                 << BSON_ARRAY(BSON("index" << 1 << "details"
                                                            << BSON("operatorName"
                                                                    << "$lt"
                                                                    << "specifiedAs"
                                                                    << failingClause << "reason"
                                                                    << "comparison failed"
                                                                    << "consideredValue" << 11))));
    verifyGeneratedError(query, document, expectedError);
}

TEST(LogicalMatchExpression, ImplicitAnd) {
    BSONObj failingClause = BSON("a" << BSON("$lt" << 10));
    BSONObj query = BSON("a" << BSON("$gt" << 0 << "$lt" << 10));
    BSONObj document = BSON("a" << 11);
    BSONObj expectedError = BSON("operatorName"
                                 << "$and"
                                 << "clausesNotSatisfied"
                                 << BSON_ARRAY(BSON("index" << 1 << "details"
                                                            << BSON("operatorName"
                                                                    << "$lt"
                                                                    << "specifiedAs"
                                                                    << failingClause << "reason"
                                                                    << "comparison failed"
                                                                    << "consideredValue" << 11))));
    verifyGeneratedError(query, document, expectedError);
}

TEST(LogicalMatchExpression, AndMultipleFailingClauses) {
    BSONObj firstFailingClause = BSON("a" << BSON("$lt" << 10));
    BSONObj secondFailingClause = BSON("a" << BSON("$gt" << 20));
    BSONObj query = BSON("$and" << BSON_ARRAY(firstFailingClause << secondFailingClause));
    BSONObj document = BSON("a" << 15);
    BSONObj expectedError = BSON(
        "operatorName"
        << "$and"
        << "clausesNotSatisfied"
        << BSON_ARRAY(BSON("index" << 0 << "details"
                                   << BSON("operatorName"
                                           << "$lt"
                                           << "specifiedAs" << firstFailingClause << "reason"
                                           << "comparison failed"
                                           << "consideredValue" << 15))
                      << BSON("index" << 1 << "details"
                                      << BSON("operatorName"
                                              << "$gt"
                                              << "specifiedAs" << secondFailingClause << "reason"
                                              << "comparison failed"
                                              << "consideredValue" << 15))));
    verifyGeneratedError(query, document, expectedError);
}

// $or
TEST(LogicalMatchExpression, BasicOr) {
    BSONObj failingClause = BSON("a" << BSON("$lt" << 10));
    BSONObj query = BSON("$or" << BSON_ARRAY(failingClause));
    BSONObj document = BSON("a" << 11);
    BSONObj expectedError = BSON("operatorName"
                                 << "$or"
                                 << "clausesNotSatisfied"
                                 << BSON_ARRAY(BSON("index" << 0 << "details"
                                                            << BSON("operatorName"
                                                                    << "$lt"
                                                                    << "specifiedAs"
                                                                    << failingClause << "reason"
                                                                    << "comparison failed"
                                                                    << "consideredValue" << 11))));
    verifyGeneratedError(query, document, expectedError);
}

TEST(LogicalMatchExpression, OrMultipleFailingClauses) {
    BSONObj firstFailingClause = BSON("a" << BSON("$lt" << 10));
    BSONObj secondFailingClause = BSON("a" << BSON("$gt" << 20));
    BSONObj query = BSON("$or" << BSON_ARRAY(firstFailingClause << secondFailingClause));
    BSONObj document = BSON("a" << 15);
    BSONObj expectedError = BSON(
        "operatorName"
        << "$or"
        << "clausesNotSatisfied"
        << BSON_ARRAY(BSON("index" << 0 << "details"
                                   << BSON("operatorName"
                                           << "$lt"
                                           << "specifiedAs" << firstFailingClause << "reason"
                                           << "comparison failed"
                                           << "consideredValue" << 15))
                      << BSON("index" << 1 << "details"
                                      << BSON("operatorName"
                                              << "$gt"
                                              << "specifiedAs" << secondFailingClause << "reason"
                                              << "comparison failed"
                                              << "consideredValue" << 15))));
    verifyGeneratedError(query, document, expectedError);
}

// $nor
TEST(LogicalMatchExpression, BasicNor) {
    BSONObj firstClause = BSON("a" << BSON("$gt" << 10));
    BSONObj secondFailingClause = BSON("b" << BSON("$lt" << 10));
    BSONObj query = BSON("$nor" << BSON_ARRAY(firstClause << secondFailingClause));
    BSONObj document = BSON("a" << 9 << "b" << 9);
    BSONObj expectedError =
        BSON("operatorName"
             << "$nor"
             << "clausesNotSatisfied"
             << BSON_ARRAY(BSON("index" << 1 << "details"
                                        << BSON("operatorName"
                                                << "$lt"
                                                << "specifiedAs" << secondFailingClause << "reason"
                                                << "comparison succeeded"
                                                << "consideredValue" << 9))));
    verifyGeneratedError(query, document, expectedError);
}

TEST(LogicalMatchExpression, NorAllSuccessfulClauses) {
    BSONObj firstFailingClause = BSON("a" << BSON("$lt" << 20));
    BSONObj secondFailingClause = BSON("a" << BSON("$gt" << 10));
    BSONObj query = BSON("$nor" << BSON_ARRAY(firstFailingClause << secondFailingClause));
    BSONObj document = BSON("a" << 15);
    BSONObj expectedError = BSON(
        "operatorName"
        << "$nor"
        << "clausesNotSatisfied"
        << BSON_ARRAY(BSON("index" << 0 << "details"
                                   << BSON("operatorName"
                                           << "$lt"
                                           << "specifiedAs" << firstFailingClause << "reason"
                                           << "comparison succeeded"
                                           << "consideredValue" << 15))
                      << BSON("index" << 1 << "details"
                                      << BSON("operatorName"
                                              << "$gt"
                                              << "specifiedAs" << secondFailingClause << "reason"
                                              << "comparison succeeded"
                                              << "consideredValue" << 15))));
    verifyGeneratedError(query, document, expectedError);
}

// $not
TEST(LogicalMatchExpression, BasicNot) {
    BSONObj failingClause = BSON("$lt" << 10);
    BSONObj failingQuery = BSON("a" << failingClause);
    BSONObj query = BSON("a" << BSON("$not" << failingClause));
    BSONObj document = BSON("a" << 9);
    BSONObj expectedError = BSON("operatorName"
                                 << "$not"
                                 << "details"
                                 << BSON("operatorName"
                                         << "$lt"
                                         << "specifiedAs" << failingQuery << "reason"
                                         << "comparison succeeded"
                                         << "consideredValue" << 9));
    verifyGeneratedError(query, document, expectedError);
}

TEST(LogicalMatchExpression, NotOverImplicitAnd) {
    BSONObj failingQuery = BSON("$lt" << 20 << "$gt" << 5);
    BSONObj query = BSON("a" << BSON("$not" << failingQuery));
    BSONObj document = BSON("a" << 10);
    BSONObj expectedError =
        BSON("operatorName"
             << "$not"
             << "details"
             << BSON("operatorName"
                     << "$and"
                     << "clausesNotSatisfied"
                     << BSON_ARRAY(
                            BSON("index" << 0 << "details"
                                         << BSON("operatorName"
                                                 << "$lt"
                                                 << "specifiedAs" << BSON("a" << BSON("$lt" << 20))
                                                 << "reason"
                                                 << "comparison succeeded"
                                                 << "consideredValue" << 10))
                            << BSON("index" << 1 << "details"
                                            << BSON("operatorName"
                                                    << "$gt"
                                                    << "specifiedAs"
                                                    << BSON("a" << BSON("$gt" << 5)) << "reason"
                                                    << "comparison succeeded"
                                                    << "consideredValue" << 10)))));
    verifyGeneratedError(query, document, expectedError);
}

TEST(LogicalMatchExpression, NestedNot) {
    BSONObj failingClause = BSON("$lt" << 10);
    BSONObj failingQuery = BSON("a" << failingClause);
    BSONObj query = BSON("a" << BSON("$not" << BSON("$not" << failingClause)));
    BSONObj document = BSON("a" << 11);
    BSONObj expectedError = BSON("operatorName"
                                 << "$not"
                                 << "details"
                                 << BSON("operatorName"
                                         << "$not"
                                         << "details"
                                         << BSON("operatorName"
                                                 << "$lt"
                                                 << "specifiedAs" << failingQuery << "reason"
                                                 << "comparison failed"
                                                 << "consideredValue" << 11)));
    verifyGeneratedError(query, document, expectedError);
}

// Combine logical operators
TEST(LogicalMatchExpression, NestedAndOr) {
    BSONObj query = fromjson(
        "{'$and':["
        "   {'$or': "
        "       [{'price': {'$gt': 50}}, "
        "       {'price': {'$lt': 20}}]},"
        "   {'qty': {'$gt': 0}},"
        "   {'qty': {'$lt': 10}}]}");
    BSONObj document = fromjson("{'price': 30, 'qty': 30}");
    BSONObj expectedError = fromjson(
        "{'operatorName': '$and',"
        "'clausesNotSatisfied': ["
        "   {'index': 0, 'details': "
        "   {'operatorName': '$or',"
        "   'clausesNotSatisfied': ["
        "       {'index': 0, 'details': "
        "           {'operatorName': '$gt',"
        "           'specifiedAs': {'price': {'$gt': 50}},"
        "           'reason': 'comparison failed',"
        "           'consideredValue': 30}},"
        "       {'index': 1, 'details':"
        "           {'operatorName': '$lt',"
        "           'specifiedAs': {'price': {'$lt': 20}},"
        "           'reason': 'comparison failed',"
        "           'consideredValue': 30}}]}}, "
        "   {'index': 2, 'details': "
        "   {'operatorName': '$lt',"
        "    'specifiedAs': {'qty': {'$lt': 10}},"
        "    'reason': 'comparison failed',"
        "    'consideredValue': 30}}]}");
    verifyGeneratedError(query, document, expectedError);
}

TEST(LogicalMatchExpression, NestedAndOrOneFailingClause) {
    BSONObj query = fromjson(
        "{'$and':["
        "   {'$or':[{'price': {'$lt': 20}}]},"
        "   {'qty': {'$gt': 0}},"
        "   {'qty': {'$lt': 10}}]}");
    BSONObj document = fromjson("{'price': 15, 'qty': 30}");
    BSONObj expectedError = fromjson(
        "{'operatorName': '$and',"
        "'clausesNotSatisfied': ["
        "   {'index': 2, 'details': "
        "   {'operatorName': '$lt',"
        "    'specifiedAs': {'qty': {'$lt': 10}},"
        "    'reason': 'comparison failed',"
        "    'consideredValue': 30}}]}");
    verifyGeneratedError(query, document, expectedError);
}

TEST(LogicalMatchExpression, NestedAndOrNorOneSuccessfulClause) {
    BSONObj query = fromjson(
        "{'$and':["
        "   {'$or': ["
        "       {'price': {'$lt': 20}}]},"
        "   {'$nor':["
        "       {'qty': {'$gt': 20}},"
        "       {'qty': {'$lt': 20}}]}]}");
    BSONObj document = fromjson("{'price': 10, 'qty': 15}");
    BSONObj expectedError = fromjson(
        "{'operatorName': '$and',"
        "'clausesNotSatisfied': ["
        "   {'index': 1, 'details': "
        "   {'operatorName': '$nor',"
        "   'clausesNotSatisfied': ["
        "       {'index': 1, 'details':"
        "           {'operatorName': '$lt',"
        "           'specifiedAs': {'qty': {'$lt': 20}},"
        "           'reason': 'comparison succeeded',"
        "           'consideredValue': 15}}]}}]}");
    verifyGeneratedError(query, document, expectedError);
}

TEST(LogicalMatchExpression, NestedAndOrNorNotOneFailingClause) {
    BSONObj query = fromjson(
        "{'$and':["
        "   {'$or': ["
        "       {'price': {'$lt': 20}}]},"
        "   {'$nor':["
        "       {'qty': {'$gt': 30}},"
        "       {'qty': {'$not': {'$lt': 20}}}]}]}");
    BSONObj document = fromjson("{'price': 10, 'qty': 25}");
    BSONObj expectedError = fromjson(
        "{'operatorName': '$and',"
        "'clausesNotSatisfied': ["
        "   {'index': 1, 'details': "
        "   {'operatorName': '$nor',"
        "   'clausesNotSatisfied': ["
        "       {'index': 1, 'details':"
        "           {'operatorName': '$not',"
        "            'details':             "
        "               {'operatorName': '$lt',"
        "               'specifiedAs': {'qty': {'$lt': 20}},"
        "               'reason': 'comparison failed',"
        "               'consideredValue': 25}}}]}}]}");
    verifyGeneratedError(query, document, expectedError);
}
// Miscellaneous operators.
// $exists
TEST(MiscellaneousMatchExpression, BasicExists) {
    BSONObj query = BSON("a" << BSON("$exists" << true));
    BSONObj document = BSON("b" << 1);
    BSONObj expectedError = BSON("operatorName"
                                 << "$exists"
                                 << "specifiedAs" << query << "reason"
                                 << "path does not exist");
    verifyGeneratedError(query, document, expectedError);
}
TEST(MiscellaneousMatchExpression, NotExists) {
    BSONObj query = BSON("a" << BSON("$exists" << false));
    BSONObj document = BSON("a" << 1);
    BSONObj expectedError = BSON("operatorName"
                                 << "$exists"
                                 << "specifiedAs" << query << "reason"
                                 << "path does exist");
    verifyGeneratedError(query, document, expectedError);
}
// $type
TEST(MiscellaneousMatchExpression, BasicType) {
    BSONObj query = BSON("a" << BSON("$type"
                                     << "int"));
    BSONObj document = BSON("a"
                            << "one");
    BSONObj expectedError = BSON("operatorName"
                                 << "$type"
                                 << "specifiedAs" << query << "reason"
                                 << "no matching types found for specified typeset"
                                 << "consideredValue"
                                 << "one"
                                 << "consideredType"
                                 << "string");
    verifyGeneratedError(query, document, expectedError);
}
TEST(MiscellaneousMatchExpression, NotType) {
    BSONObj failingClause = BSON("$type"
                                 << "string");
    BSONObj failingQuery = BSON("a" << failingClause);
    BSONObj query = BSON("a" << BSON("$not" << failingClause));
    BSONObj document = BSON("a"
                            << "words");
    BSONObj expectedError = BSON("operatorName"
                                 << "$not"
                                 << "details"
                                 << BSON("operatorName"
                                         << "$type"
                                         << "specifiedAs" << failingQuery << "reason"
                                         << "matching types found for specified typeset"
                                         << "consideredValue"
                                         << "words"
                                         << "consideredType"
                                         << "string"));
    verifyGeneratedError(query, document, expectedError);
}
TEST(MiscellaneousMatchExpression, TypeMissingPath) {
    BSONObj query = BSON("a" << BSON("$type"
                                     << "double"));
    BSONObj document = BSON("b" << 1);
    BSONObj expectedError = BSON("operatorName"
                                 << "$type"
                                 << "specifiedAs" << query << "reason"
                                 << "field was missing");
    verifyGeneratedError(query, document, expectedError);
}
TEST(MiscellaneousMatchExpression, TypeImplicitArrayTraversal) {
    BSONObj query = BSON("a" << BSON("$type"
                                     << "double"));
    BSONObj document = BSON("a" << BSON_ARRAY("x"
                                              << "y"
                                              << "z"));
    BSONObj expectedError = BSON("operatorName"
                                 << "$type"
                                 << "specifiedAs" << query << "reason"
                                 << "no matching types found for specified typeset"
                                 << "consideredValues"
                                 << BSON_ARRAY("x"
                                               << "y"
                                               << "z"
                                               << BSON_ARRAY("x"
                                                             << "y"
                                                             << "z"))
                                 << "consideredTypes"
                                 << BSON_ARRAY("array"
                                               << "string"));
    verifyGeneratedError(query, document, expectedError);
}
// $expr
TEST(MiscellaneousMatchExpression, BasicExpr) {
    BSONObj query = BSON("$expr" << BSON("$eq" << BSON_ARRAY("$a"
                                                             << "$b")));
    BSONObj document = BSON("a" << 1 << "b" << 2);
    BSONObj expectedError = BSON("operatorName"
                                 << "$expr"
                                 << "specifiedAs" << query << "reason"
                                 << "$expr did not match"
                                 << "expressionResult" << false);
    verifyGeneratedError(query, document, expectedError);
}
TEST(MiscellaneousMatchExpression, NorExpr) {
    BSONObj failingClause = BSON("$eq" << BSON_ARRAY("$a"
                                                     << "$b"));
    BSONObj failingQuery = BSON("$expr" << failingClause);
    BSONObj query = BSON("$nor" << BSON_ARRAY(failingQuery));
    BSONObj document = BSON("a" << 1 << "b" << 1);
    BSONObj expectedError = BSON("operatorName"
                                 << "$nor"
                                 << "clausesNotSatisfied"
                                 << BSON_ARRAY(BSON(
                                        "index" << 0 << "details"
                                                << BSON("operatorName"
                                                        << "$expr"
                                                        << "specifiedAs" << failingQuery << "reason"
                                                        << "$expr did match"
                                                        << "expressionResult" << true))));
    verifyGeneratedError(query, document, expectedError);
}
TEST(MiscellaneousMatchExpression, ExprImplicitArrayTraversal) {
    BSONObj query = BSON("$expr" << BSON("$eq" << BSON_ARRAY("$a"
                                                             << "$b")));
    BSONObj document = BSON("a" << BSON_ARRAY(0 << 1 << 2) << "b" << BSON_ARRAY(3 << 4 << 5));
    BSONObj expectedError = BSON("operatorName"
                                 << "$expr"
                                 << "specifiedAs" << query << "reason"
                                 << "$expr did not match"
                                 << "expressionResult" << false);
    verifyGeneratedError(query, document, expectedError);
}
// $mod
TEST(MiscellaneousMatchExpression, BasicMod) {
    BSONObj query = BSON("a" << BSON("$mod" << BSON_ARRAY(2 << 1)));
    BSONObj document = BSON("a" << 2);
    BSONObj expectedError = BSON("operatorName"
                                 << "$mod"
                                 << "specifiedAs" << query << "reason"
                                 << "$mod did not evaluate to expected remainder"
                                 << "consideredValue" << 2);
    verifyGeneratedError(query, document, expectedError);
}
TEST(MiscellaneousMatchExpression, NotMod) {
    BSONObj failingClause = BSON("$mod" << BSON_ARRAY(2 << 1));
    BSONObj failingQuery = BSON("a" << failingClause);
    BSONObj query = BSON("a" << BSON("$not" << failingClause));
    BSONObj document = BSON("a" << 2);
    BSONObj expectedError = BSON("operatorName"
                                 << "$not"
                                 << "details"
                                 << BSON("operatorName"
                                         << "$mod"
                                         << "specifiedAs" << failingQuery << "reason"
                                         << "$mod did evaluate to expected remainder"
                                         << "consideredValue" << 2));
    verifyGeneratedError(query, document, expectedError);
}
TEST(MiscellaneousMatchExpression, ModMissingPath) {
    BSONObj query = BSON("a" << BSON("$mod" << BSON_ARRAY(2 << 1)));
    BSONObj document = BSON("b" << 2);
    BSONObj expectedError = BSON("operatorName"
                                 << "$mod"
                                 << "specifiedAs" << query << "reason"
                                 << "field was missing");
    verifyGeneratedError(query, document, expectedError);
}
TEST(MiscellaneousMatchExpression, ModImplicitArrayTraversal) {
    BSONObj query = BSON("a" << BSON("$mod" << BSON_ARRAY(2 << 1)));
    BSONObj document = BSON("a" << BSON_ARRAY(0 << 2 << 4));
    BSONObj expectedError = BSON("operatorName"
                                 << "$mod"
                                 << "specifiedAs" << query << "reason"
                                 << "$mod did not evaluate to expected remainder"
                                 << "consideredValues"
                                 << BSON_ARRAY(0 << 2 << 4 << BSON_ARRAY(0 << 2 << 4)));
    verifyGeneratedError(query, document, expectedError);
}
TEST(MiscellaneousMatchExpression, ModNonNumeric) {
    BSONObj query = BSON("a" << BSON("$mod" << BSON_ARRAY(2 << 1)));
    BSONObj document = BSON("a"
                            << "two");
    BSONObj expectedError = BSON("operatorName"
                                 << "$mod"
                                 << "specifiedAs" << query << "reason"
                                 << "type mismatch"
                                 << "consideredType"
                                 << "string"
                                 << "expectedTypes"
                                 << BSON_ARRAY("decimal"
                                               << "double"
                                               << "int"
                                               << "long")
                                 << "consideredValue"
                                 << "two");
    verifyGeneratedError(query, document, expectedError);
}
TEST(MiscellaneousMatchExpression, ModImplicitArrayTraversalNonNumeric) {
    BSONObj query = BSON("a" << BSON("$mod" << BSON_ARRAY(2 << 1)));
    BSONObj document = BSON("a" << BSON_ARRAY("zero"
                                              << "two"
                                              << "four"));
    BSONObj expectedError = BSON("operatorName"
                                 << "$mod"
                                 << "specifiedAs" << query << "reason"
                                 << "type mismatch"
                                 << "consideredTypes"
                                 << BSON_ARRAY("array"
                                               << "string")
                                 << "expectedTypes"
                                 << BSON_ARRAY("decimal"
                                               << "double"
                                               << "int"
                                               << "long")
                                 << "consideredValues"
                                 << BSON_ARRAY("zero"
                                               << "two"
                                               << "four"
                                               << BSON_ARRAY("zero"
                                                             << "two"
                                                             << "four")));
    verifyGeneratedError(query, document, expectedError);
}
TEST(MiscellaneousMatchExpression, ModImplicitArrayTraversalMixedTypes) {
    BSONObj query = BSON("a" << BSON("$mod" << BSON_ARRAY(2 << 1)));
    BSONObj document = BSON("a" << BSON_ARRAY(0 << "two"
                                                << "four"));
    BSONObj expectedError = BSON("operatorName"
                                 << "$mod"
                                 << "specifiedAs" << query << "reason"
                                 << "$mod did not evaluate to expected remainder"
                                 << "consideredValues"
                                 << BSON_ARRAY(0 << "two"
                                                 << "four"
                                                 << BSON_ARRAY(0 << "two"
                                                                 << "four")));
    verifyGeneratedError(query, document, expectedError);
}
// $regex
TEST(MiscellaneousMatchExpression, BasicRegex) {
    BSONObj query = BSON("a" << BSON("$regex" << BSONRegEx("/myRegex/", "") << "$options"
                                              << ""));
    BSONObj document = BSON("a"
                            << "one");
    BSONObj expectedError = BSON("operatorName"
                                 << "$regex"
                                 << "specifiedAs" << query << "reason"
                                 << "regular expression did not match"
                                 << "consideredValue"
                                 << "one");
    verifyGeneratedError(query, document, expectedError);
}
TEST(MiscellaneousMatchExpression, NotRegex) {
    BSONObj failingClause = BSON("$regex" << BSONRegEx("/myRegex/", "") << "$options"
                                          << "");
    BSONObj failingQuery = BSON("a" << failingClause);
    BSONObj query = BSON("a" << BSON("$not" << failingClause));
    BSONObj document = BSON("a"
                            << "one");
    BSONObj expectedError = BSON("operatorName"
                                 << "$not"
                                 << "details"
                                 << BSON("operatorName"
                                         << "$regex"
                                         << "specifiedAs" << failingQuery << "reason"
                                         << "regular expression did match"
                                         << "consideredValue"
                                         << "one"));
    verifyGeneratedError(query, document, expectedError);
}
TEST(MiscellaneousMatchExpression, RegexMissingPath) {
    BSONObj query = BSON("a" << BSON("$regex" << BSONRegEx("/myRegex/", "") << "$options"
                                              << ""));
    BSONObj document = BSON("b"
                            << "myRegex");
    BSONObj expectedError = BSON("operatorName"
                                 << "$regex"
                                 << "specifiedAs" << query << "reason"
                                 << "field was missing");
    verifyGeneratedError(query, document, expectedError);
}
TEST(MiscellaneousMatchExpression, RegexImplicitArrayTraversal) {
    BSONObj query = BSON("a" << BSON("$regex" << BSONRegEx("/myRegex/", "") << "$options"
                                              << ""));
    BSONObj document = BSON("a" << BSON_ARRAY("x"
                                              << "y"
                                              << "z"));
    BSONObj expectedError = BSON("operatorName"
                                 << "$regex"
                                 << "specifiedAs" << query << "reason"
                                 << "regular expression did not match"
                                 << "consideredValues"
                                 << BSON_ARRAY("x"
                                               << "y"
                                               << "z"
                                               << BSON_ARRAY("x"
                                                             << "y"
                                                             << "z")));
    verifyGeneratedError(query, document, expectedError);
}
TEST(MiscellaneousMatchExpression, RegexNonString) {
    BSONObj query = BSON("a" << BSON("$regex" << BSONRegEx("/myRegex/", "") << "$options"
                                              << ""));
    BSONObj document = BSON("a" << 1);
    BSONObj expectedError = BSON("operatorName"
                                 << "$regex"
                                 << "specifiedAs" << query << "reason"
                                 << "type mismatch"
                                 << "consideredType"
                                 << "int"
                                 << "expectedTypes"
                                 << BSON_ARRAY("regex"
                                               << "string"
                                               << "symbol")
                                 << "consideredValue" << 1);
    verifyGeneratedError(query, document, expectedError);
}
TEST(MiscellaneousMatchExpression, RegexImplicitArrayTraversalNonString) {
    BSONObj query = BSON("a" << BSON("$regex" << BSONRegEx("/myRegex/", "") << "$options"
                                              << ""));
    BSONObj document = BSON("a" << BSON_ARRAY(0 << 1 << 2));
    BSONObj expectedError = BSON("operatorName"
                                 << "$regex"
                                 << "specifiedAs" << query << "reason"
                                 << "type mismatch"
                                 << "consideredTypes"
                                 << BSON_ARRAY("array"
                                               << "int")
                                 << "expectedTypes"
                                 << BSON_ARRAY("regex"
                                               << "string"
                                               << "symbol")
                                 << "consideredValues"
                                 << BSON_ARRAY(0 << 1 << 2 << BSON_ARRAY(0 << 1 << 2)));
    verifyGeneratedError(query, document, expectedError);
}
TEST(MiscellaneousMatchExpression, RegexImplicitArrayTraversalMixedTypes) {
    BSONObj query = BSON("a" << BSON("$regex" << BSONRegEx("/myRegex/", "") << "$options"
                                              << ""));
    BSONObj document = BSON("a" << BSON_ARRAY("x" << 1 << 2));
    BSONObj expectedError = BSON("operatorName"
                                 << "$regex"
                                 << "specifiedAs" << query << "reason"
                                 << "regular expression did not match"
                                 << "consideredValues"
                                 << BSON_ARRAY("x" << 1 << 2 << BSON_ARRAY("x" << 1 << 2)));
    verifyGeneratedError(query, document, expectedError);
}
}  // namespace
}  // namespace mongo
