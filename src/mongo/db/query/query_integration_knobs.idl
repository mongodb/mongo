# Copyright (C) 2026-present MongoDB, Inc.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the Server Side Public License, version 1,
# as published by MongoDB, Inc.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# Server Side Public License for more details.
#
# You should have received a copy of the Server Side Public License
# along with this program. If not, see
# <http://www.mongodb.com/licensing/server-side-public-license>.
#
# As a special exception, the copyright holders give permission to link the
# code of portions of this program with the OpenSSL library under certain
# conditions as described in each individual source file and distribute
# linked combinations including the program with the OpenSSL library. You
# must comply with the Server Side Public License in all respects for
# all of the code used other than as permitted herein. If you modify file(s)
# with this exception, you may extend this exception to your version of the
# file(s), but you are not obligated to do so. If you do not wish to do so,
# delete this exception statement from your version. If you delete this
# exception statement from all source files in the program, then also delete
# it in the license file.
#

imports:
    - "mongo/db/topology/cluster_parameters/cluster_server_parameter.idl"

global:
    cpp_namespace: "mongo"
    cpp_includes:
        - "mongo/db/query/plan_cache/sbe_plan_cache_on_parameter_change.h"
        - "mongo/db/query/query_knob_expressions.h"
        - "mongo/db/query/query_stats/query_stats_on_parameter_change.h"
        - "mongo/platform/atomic_word.h"
    mod_visibility: public

structs:
    InternalVectorSearchStoredSource:
        description: "A specification for the 'internalVectorSearchStoredSource' cluster-wide configuration parameter type."
        inline_chained_structs: true
        chained_structs:
            ClusterServerParameter: clusterServerParameter
        fields:
            enabled:
                description: "Whether $vectorSearch supports 'returnStoredSource: true' or not."
                type: bool
                default: true

server_parameters:
    enableSearchMeta:
        description: >-
            Exists for backwards compatibility in startup parameters, enabling this was
            required on 4.4 to access SEARCH_META variables. Does not do anything.
        set_at: [startup, runtime]
        cpp_varname: "enableSearchMeta"
        cpp_vartype: AtomicWord<bool>
        default: true
        redact: false

    internalQueryFLERewriteMemoryLimit:
        description: >-
            Maximum memory available for encrypted field query rewrites in bytes. Must be
            more than zero and less than 16Mb
        set_at: [startup, runtime]
        cpp_varname: "internalQueryFLERewriteMemoryLimit"
        cpp_vartype: AtomicWord<int>
        default:
            expr: 14 * 1024 * 1024
        validator:
            gt: 0
            lt: 16777216
        redact: false

    internalQueryFLEAlwaysUseEncryptedCollScanMode:
        description: "Boolean flag to force FLE to always use low selectivity mode"
        set_at: [startup, runtime]
        cpp_varname: "internalQueryFLEAlwaysUseEncryptedCollScanMode"
        cpp_vartype: AtomicWord<bool>
        default:
            expr: false
        redact: false

    internalQueryStatsRateLimit:
        description: >-
            The maximum number of queries per second that are sampled for query stats using window-based rate limiting.
            If the rate of queries goes above this number, then rate limiting will kick in, and any
            further queries will not be sampled. To sample all queries, this can be set to -1.
            When both internalQueryStatsSampleRate and internalQueryStatsRateLimit are set to non-zero
            values, the sampling-based rate limiting takes precedence over this window-based rate limiting. To disable
            query stats collection completely, set both internalQueryStatsRateLimit and internalQueryStatsSampleRate to 0.
        set_at: [startup, runtime]
        cpp_varname: "internalQueryStatsRateLimit"
        cpp_vartype: AtomicWord<int>
        default: 0
        validator:
            gte: -1
        on_update: query_stats_util::onQueryStatsRateLimitUpdate
        redact: false

    internalQueryStatsSampleRate:
        description: >-
            The fractional number representing the rate of the queries that are sampled for query stats using
            sampling-based rate limiting. To sample all queries, this can be set to 1.
            When both internalQueryStatsSampleRate and internalQueryStatsRateLimit are set to non-zero
            values, this sampling-based rate limiting takes precedence over window-based rate limiting.
            If internalQueryStatsSampleRate is set to 0, query sampling will be controlled by the window-based
            rate limiter. To disable query stats collection completely, set both internalQueryStatsSampleRate and
            internalQueryStatsRateLimit to 0.
        set_at: [startup, runtime]
        cpp_varname: "internalQueryStatsSampleRate"
        cpp_vartype: AtomicWord<double>
        default: 0
        validator:
            gte: 0.0
            lte: 1.0
        on_update: query_stats_util::onQueryStatsSamplingRateUpdate
        redact: false

    internalQueryStatsWriteCmdSampleRate:
        description: >-
            Controls whether query stats are collected for write commands. Set to 1 to enable collection for
            write commands, or 0 to disable. This parameter is only effective if query stats is already enabled
            via 'internalQueryStatsRateLimit' or 'internalQueryStatsSampleRate'.
            Note: This parameter may become a floating point value to support percentage-based sampling.
        set_at: [startup, runtime]
        cpp_varname: "internalQueryStatsWriteCmdSampleRate"
        cpp_vartype: AtomicWord<double>
        default: 1.0
        validator:
            gte: 0.0
            lte: 1.0
            callback: query_stats_util::validateQueryStatsWriteCmdSampleRate
        redact: false

    internalQueryStatsCacheSize:
        description: >-
            The maximum amount of memory that the system will allocate for the query queryStats
            cache. This will accept values in either of the following formats:
            1. <number>% indicates a percentage of the physical memory available to the process. E.g.: 15%.
            2. <number>(MB|GB), indicates the amount of memory in MB or GB. E.g.: 1.5GB, 100MB.
            The default value is 1%, which means 1% of the physical memory available to the process.
        set_at: [startup, runtime]
        cpp_varname: "internalQueryStatsCacheSize"
        cpp_vartype: synchronized_value<std::string>
        default: "1%"
        on_update: query_stats_util::onQueryStatsStoreSizeUpdate
        validator:
            callback: query_stats_util::validateQueryStatsStoreSize
        redact: false

    internalQueryStatsErrorsAreCommandFatal:
        description: >-
            Whether errors in the $queryStats stage cause the aggregation pipeline to
            immediately fail and report the error. Note that this is always the case for debug builds.
        set_at: [startup, runtime]
        cpp_varname: "internalQueryStatsErrorsAreCommandFatal"
        cpp_vartype: AtomicWord<bool>
        default: false
        redact: false

    internalQueryGlobalProfilingFilter:
        description: "Enables the setProfilingFilterGlobally command."
        set_at: [startup, runtime]
        cpp_varname: internalQueryGlobalProfilingFilter
        cpp_vartype: AtomicWord<bool>
        default: false
        redact: false

    internalQueryGlobalProfilingLockDeadlineMs:
        description: >-
            A number of milliseconds to wait for a lock acquisition to perform writes to the
            system.profile collection.
        set_at: [startup, runtime]
        cpp_varname: internalQueryGlobalProfilingLockDeadlineMs
        cpp_vartype: AtomicWord<int>
        default: 1
        redact: false
        validator:
            gte: 0

    internalProfilingMaxAbandonedWritesPerSecondPerDb:
        description: >-
            If there are at least this many lock timeouts when trying to profile, we will skip all
            future profiling for a given database. Lasts until profiling is manually re-enabled. The
            value can be zero, in which case even a single lock timeout will disable profiling for
            the db.
        set_at: [startup, runtime]
        cpp_varname: internalProfilingMaxAbandonedWritesPerSecondPerDb
        cpp_vartype: AtomicWord<int>
        default: 1000
        redact: false
        validator:
            gte: 0

    internalQueryCollectOptimizerMetrics:
        description: "If true, collect query optimizer metrics in queryStats."
        set_at: [startup, runtime]
        cpp_varname: internalQueryCollectOptimizerMetrics
        cpp_vartype: AtomicWord<bool>
        default: false
        redact: false

    internalVectorSearchStoredSource:
        description: >-
            Controls whether $vectorSearch supports returnStoredSource: true as an option.
        set_at: cluster
        cpp_varname: internalVectorSearchStoredSource
        cpp_vartype: InternalVectorSearchStoredSource
        redact: false
        omit_in_ftdc: false
        condition:
            min_fcv: 8.2

    # TODO SERVER-85426 Remove this knob.
    bypassRankFusionFCVGate:
        description: "If enabled, bypasses FCV-gating for featureFlagRankFusionBasic and featureFlagRankFusionFull."
        set_at: [startup]
        cpp_varname: bypassRankFusionFCVGate
        cpp_vartype: bool
        default: false
        redact: false
# Note for adding additional query knobs:
#
# When adding a new query knob, you should consider whether or not you need to add an 'on_update'
# hook to flush the SBE plan cache. If your knob affects the contents of SBE plans which may be
# cached, then the SBE cache should be flushed when the value of the knob changes. This will ensure
# that the application actually starts to get plans which reflect the new value of the knob, rather
# than continuing to use stale cached plans.
#
# When adding a new query knob which flushes the SBE plan cache on update, you should test this
# behavior by including the name of the new knob in the list at the top of the jstest
# 'sbe_plan_cache_clear_on_param_change.js'.
#
# When adding a new runtime query knob, consider adding and accessing it through the
# 'QueryKnobConfiguration' decoration, especially if it may be accessed multiple times during a
# query lifetime.
