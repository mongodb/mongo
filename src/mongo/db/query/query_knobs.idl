# Copyright (C) 2019-present MongoDB, Inc.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the Server Side Public License, version 1,
# as published by MongoDB, Inc.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# Server Side Public License for more details.
#
# You should have received a copy of the Server Side Public License
# along with this program. If not, see
# <http://www.mongodb.com/licensing/server-side-public-license>.
#
# As a special exception, the copyright holders give permission to link the
# code of portions of this program with the OpenSSL library under certain
# conditions as described in each individual source file and distribute
# linked combinations including the program with the OpenSSL library. You
# must comply with the Server Side Public License in all respects for
# all of the code used other than as permitted herein. If you modify file(s)
# with this exception, you may extend this exception to your version of the
# file(s), but you are not obligated to do so. If you do not wish to do so,
# delete this exception statement from your version. If you delete this
# exception statement from all source files in the program, then also delete
# it in the license file.
#

imports:
  - "mongo/idl/cluster_server_parameter.idl"

global:
  cpp_namespace: "mongo"
  cpp_includes:
    - "mongo/db/query/cost_model/cost_model_on_update.h"
    - "mongo/db/query/ce_mode_parameter.h"
    - "mongo/db/query/explain_version_validator.h"
    - "mongo/db/query/sbe_plan_cache_on_parameter_change.h"
    - "mongo/db/query/query_stats/query_stats_on_parameter_change.h"
    - "mongo/platform/atomic_proxy.h"
    - "mongo/platform/atomic_word.h"

enums:
    QueryFrameworkControl:
        description: "Enum for possible values of internalQueryFrameworkControl."
        type: string
        values:
            # Force the classic query engine for all queries.
            kForceClassicEngine: "forceClassicEngine"
            # Only allow pushdown of certain agg stages to SBE including $group, $lookup,
            # $_internalUnpackBucket, and search. If none of these stages are present and can be
            # pushed down, fall back to the classic engine. 'featureFlagSbeFull' can override this,
            # and allow for all supported stages to be pushed down.
            kTrySbeRestricted: "trySbeRestricted"
            # Attempt to use SBE for eligible queries, otherwise fallback to the classic engine.
            kTrySbeEngine: "trySbeEngine"
            # Attempt to use the Bonsai optimizer and lower to SBE for eligible queries, otherwise
            # fallback to the default framework control.
            kTryBonsai: "tryBonsai"
            # Like, "tryBonsai", but additionally includes features that should not be enabled by
            # default. Falls back to the default framework control for ineligible queries.
            kTryBonsaiExperimental: "tryBonsaiExperimental"
            # Force the Bonsai optimizer for all queries.
            kForceBonsai: "forceBonsai"

structs:
  InternalQueryCutoffForSampleFromRandomCursorStorage:
    description: "A specification for the 'internalQueryCutoffForSampleFromRandomCursor' cluster-wide configuration parameter type."
    inline_chained_structs: true
    chained_structs:
      ClusterServerParameter: clusterServerParameter
    fields:
      sampleCutoff:
        description: "The configuration for random-cursor sample cutoffs."
        type: double
        default: 0.05
        validator:
          gt: 0.0
          lte: 1.0

server_parameters:

  #
  # multi-plan ranking
  #
  internalQueryPlanEvaluationWorks:
    description: "For small collections, the max number of times we call work() on plans during the
    runtime plan selection trial period. Applies only to the classic execution engine. The complete
    formula for calculating the maximum trial period works depends on
    'internalQueryPlanEvaluationCollFraction' as well as this parameter."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryPlanEvaluationWorks"
    cpp_vartype: AtomicWord<int>
    default: 10000
    validator:
      gt: 0

  internalQueryPlanEvaluationWorksSbe:
    description: "The maximum number of individual storage cursor reads performed by any candidate
    plan during the runtime plan selection trial period. Applies only to queries using the SBE
    execution engine. This is the analog of the 'internalQueryPlanEvaluationWorks' knob above but
    for SBE. When 'internalQueryPlanEvaluationCollFractionSbe' has its default value of 0, this
    parameter acts as a hard limit on trial period length regardless of collection size."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryPlanEvaluationWorksSbe"
    cpp_vartype: AtomicWord<int>
    default: 10000
    validator:
      gt: 0
    on_update: plan_cache_util::clearSbeCacheOnParameterChange

  internalQueryPlanEvaluationCollFraction:
    description: "For large collections, the ceiling for the number times we work() candidate plans
    is taken as this fraction of the collection size. Applies only to the classic execution engine."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryPlanEvaluationCollFraction"
    cpp_vartype: AtomicDouble
    default: 0.3
    validator:
      gte: 0.0
      lte: 1.0

  internalQueryPlanEvaluationCollFractionSbe:
    description: "For large collections, the ceiling for the number of individual storage cursor
    reads allowed during the multi-planning trial period is calculated based on this constant.
    Applies only for for queries using the SBE execution engine. This is the analog of the
    'internalQueryPlanEvaluationCollFraction' knob above but for SBE."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryPlanEvaluationCollFractionSbe"
    cpp_vartype: AtomicDouble
    default: 0.0
    validator:
      gte: 0.0
      lte: 1.0
    on_update: plan_cache_util::clearSbeCacheOnParameterChange

  internalQueryPlanEvaluationMaxResults:
    description: "Stop working plans once a plan returns this many results."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryPlanEvaluationMaxResults"
    cpp_vartype: AtomicWord<int>
    default: 101
    validator:
      gte: 0
    on_update: plan_cache_util::clearSbeCacheOnParameterChange

  internalQueryPlanTieBreakingWithIndexHeuristics:
    description: "Tie-breaking rules which choose the plan that fetches the smallest number of
    documents or examines fewest index keys, as well as one that can be assigned the longest
    contiguous prefix of equality predicates in any index."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryPlanTieBreakingWithIndexHeuristics"
    cpp_vartype: AtomicWord<bool>
    default: true

  internalQueryForceIntersectionPlans:
    description: "Gives a large ranking bonus to index intersection plans, forcing intersection
    plans to be chosen when possible."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryForceIntersectionPlans"
    cpp_vartype: AtomicWord<bool>
    default: false
    on_update: plan_cache_util::clearSbeCacheOnParameterChange

  internalQueryPlannerEnableIndexIntersection:
    description: "Controls whether the planner will generate and consider index intersection plans."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryPlannerEnableIndexIntersection"
    cpp_vartype: AtomicWord<bool>
    default: true
    on_update: plan_cache_util::clearSbeCacheOnParameterChange

  internalQueryPlannerEnableHashIntersection:
    description: "Do we use hash-based intersection for rooted $and queries?"
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryPlannerEnableHashIntersection"
    cpp_vartype: AtomicWord<bool>
    default: false
    on_update: plan_cache_util::clearSbeCacheOnParameterChange

  internalQueryPlannerEnableIndexPruning:
    description: "Prunes unnecessary candidate plans so we trial less duplicate options."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryPlannerEnableIndexPruning"
    cpp_vartype: AtomicWord<bool>
    default: true
    on_update: plan_cache_util::clearSbeCacheOnParameterChange

  #
  # Plan cache
  #

  internalQueryDisablePlanCache:
    description:  "Disables caching of query plans for both classic and SBE engines."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryDisablePlanCache"
    cpp_vartype: AtomicWord<bool>
    default: false
    on_update: plan_cache_util::clearSbeCacheOnParameterChange

  internalQueryCacheMaxEntriesPerCollection:
    description: "The maximum number of entries allowed in a given collection's plan cache. Applies
    only to the classic plan cache, not to the SBE plan cache."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryCacheMaxEntriesPerCollection"
    cpp_vartype: AtomicWord<int>
    deprecated_name: "internalQueryCacheSize"
    default: 5000
    validator:
      gte: 0

  internalQueryCacheMaxSizeBytesBeforeStripDebugInfo:
    description: "Limits the amount of debug info stored across all plan caches in the system. Once
    the estimate of the number of bytes used across all plan caches exceeds this threshold, then
    debug info is not stored alongside new cache entries, in order to limit plan cache memory
    consumption. If plan cache entries are freed and the estimate once again dips below this
    threshold, then new cache entries will once again have debug info associated with them. Applies
    only to the classic plan cache, not to the SBE plan cache."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryCacheMaxSizeBytesBeforeStripDebugInfo"
    cpp_vartype: AtomicWord<long long>
    default:
      expr: 512 * 1024 * 1024
    validator:
      gte: 0

  internalQueryCacheEvictionRatio:
    description: "How many times more works must we perform in order to justify plan cache eviction
    and replanning?"
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryCacheEvictionRatio"
    cpp_vartype: AtomicDouble
    default: 10.0
    validator:
      gte: 0.0
    on_update: plan_cache_util::clearSbeCacheOnParameterChange

  internalQueryCacheWorksGrowthCoefficient:
    description: "How quickly the the 'works' value in an inactive cache entry will grow. It grows
    exponentially. The value of this server parameter is the base."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryCacheWorksGrowthCoefficient"
    cpp_vartype: AtomicDouble
    default: 2.0
    validator:
      gt: 1.0
    on_update: plan_cache_util::clearSbeCacheOnParameterChange

  internalQueryCacheDisableInactiveEntries:
    description: "Whether or not cache entries can be marked as 'inactive'."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryCacheDisableInactiveEntries"
    cpp_vartype: AtomicWord<bool>
    default: false
    on_update: plan_cache_util::clearSbeCacheOnParameterChange

  planCacheSize:
    description: "The maximum amount of memory that the system will allocate for the plan cache.
      It takes value value in one of the two formats:
      1. <number>% indicates a percentage of the physical memory available to the process. E.g.: 15%.
      2. <number>(MB|GB), indicates the amount of memory in MB or GB. E.g.: 1.5GB, 100MB.
      The defualt value is 5% which means 5% of the physical memory available to the process."
    set_at: [ startup, runtime ]
    cpp_varname: "planCacheSize"
    cpp_vartype: synchronized_value<std::string>
    default: "5%"
    on_update: plan_cache_util::onPlanCacheSizeUpdate
    validator:
      callback: plan_cache_util::validatePlanCacheSize

  #
  # Parsing
  #

  internalPipelineLengthLimit:
    description: "The maximum length allowed for an an aggregation pipeline."
    set_at: [ startup ]
    cpp_varname: "internalPipelineLengthLimit"
    cpp_vartype: int
    default:
      expr: 'kDebugBuild ? 200 : 1000'
    validator:
      gt: 0

  internalMaxSubPipelineViewDepth:
    description: "The maximum length allowed for an an aggregation sub-pipeline view."
    set_at: [ startup, runtime ]
    cpp_varname: "internalMaxSubPipelineViewDepth"
    cpp_vartype: AtomicWord<long long>
    default: 20
    test_only: true
    validator:
      gt: 0

  internalPartialFilterExpressionMaxDepth:
    description: "The maximum depth allowed for a partialFilterExpression."
    set_at: [ startup, runtime ]
    cpp_varname: "internalPartialFilterExpressionMaxDepth"
    cpp_vartype: AtomicWord<long long>
    default: 4
    validator:
      gt: 0

  #
  # Planning and enumeration
  #
  internalQueryPlannerMaxIndexedSolutions:
    description: "How many indexed solutions will QueryPlanner::plan output?"
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryPlannerMaxIndexedSolutions"
    cpp_vartype: AtomicWord<int>
    default: 64
    validator:
      gte: 0
    on_update: plan_cache_util::clearSbeCacheOnParameterChange

  internalQueryEnumerationPreferLockstepOrEnumeration:
    description: "If set to true, instructs the plan enumerator to enumerate contained $ors in a
    special order. $or enumeration can generate an exponential number of plans, and is therefore
    limited at some arbitrary cutoff controlled by a parameter. When this limit is hit, the order of
    enumeration is important. For example, a query like the following has a 'contained $or' (within
    an $and): {a: 1, $or: [{b: 1, c: 1}, {b: 2, c: 2}]} For this query if there are indexes
    a_b={a: 1, b: 1} and a_c={a: 1, c: 1}, the normal enumeration order would output assignments
    [a_b, a_b], [a_c, a_b], [a_b, a_c], then [a_c, a_c]. This flag will instruct the enumerator to
    instead prefer a different order. It's hard to summarize, but perhaps the phrases 'lockstep
    enumeration', 'simultaneous advancement', or 'parallel iteration' will help the reader. The
    effect is to give earlier enumeration to plans which use the same choice across all branches. In
    this order, we would get assignments [a_b, a_b], [a_c, a_c], [a_c, a_b], then [a_b, a_c]. This
    is thought to be helpful in general, but particularly in cases where all children of the $or use
    the same fields and have the same indexes available, as in this example."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryEnumerationPreferLockstepOrEnumeration"
    cpp_vartype: AtomicWord<bool>
    default: true
    on_update: plan_cache_util::clearSbeCacheOnParameterChange

  internalQueryEnumerationMaxOrSolutions:
    description: "How many solutions will the enumerator consider at each OR?"
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryEnumerationMaxOrSolutions"
    cpp_vartype: AtomicWord<int>
    default: 10
    validator:
      gte: 0
    on_update: plan_cache_util::clearSbeCacheOnParameterChange

  internalQueryEnumerationMaxIntersectPerAnd:
    description: "How many intersections will the enumerator consider at each AND?"
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryEnumerationMaxIntersectPerAnd"
    cpp_vartype: AtomicWord<int>
    default: 3
    validator:
      gte: 0
    on_update: plan_cache_util::clearSbeCacheOnParameterChange

  internalQueryPlanOrChildrenIndependently:
    description: "Do we want to plan each child of the OR independently?"
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryPlanOrChildrenIndependently"
    cpp_vartype: AtomicWord<bool>
    default: true
    on_update: plan_cache_util::clearSbeCacheOnParameterChange

  internalQueryMaxScansToExplode:
    description: "How many index scans are we willing to produce in order to obtain a sort order
    during explodeForSort?"
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryMaxScansToExplode"
    cpp_vartype: AtomicWord<int>
    default: 200
    validator:
      gte: 0
    on_update: plan_cache_util::clearSbeCacheOnParameterChange

  internalQueryPlannerGenerateCoveredWholeIndexScans:
    description: "Allow the planner to generate covered whole index scans, rather than falling back
    to a COLLSCAN."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryPlannerGenerateCoveredWholeIndexScans"
    cpp_vartype: AtomicWord<bool>
    default: false
    on_update: plan_cache_util::clearSbeCacheOnParameterChange

  internalQueryIgnoreUnknownJSONSchemaKeywords:
    description: "Ignore unknown JSON Schema keywords."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryIgnoreUnknownJSONSchemaKeywords"
    cpp_vartype: AtomicWord<bool>
    default: false

  #
  # Query execution
  #
  internalQueryMaxBlockingSortMemoryUsageBytes:
    description: "The maximum amount of memory a query (e.g. a find or aggregate command) is willing
    to use to execute a blocking sort, measured in bytes. If disk use is allowed, then it may be
    possible to sort more data, but this limit will still constrain the memory consumption."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryMaxBlockingSortMemoryUsageBytes"
    cpp_vartype: AtomicWord<int>
    default:
      expr: 100 * 1024 * 1024
    validator:
      gte: 0
    on_update: plan_cache_util::clearSbeCacheOnParameterChange

  internalQueryExecYieldIterations:
    description: "Yield after this many \"should yield?\" checks."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryExecYieldIterations"
    cpp_vartype: AtomicWord<int>
    default: 1000

  internalQueryExecYieldPeriodMS:
    description: "Yield if it's been at least this many milliseconds since we last yielded."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryExecYieldPeriodMS"
    cpp_vartype: AtomicWord<int>
    default: 10
    validator:
      gte: 0

  internalQueryFacetBufferSizeBytes:
    description: "The number of bytes to buffer at once during a $facet stage."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryFacetBufferSizeBytes"
    cpp_vartype: AtomicWord<int>
    default:
      expr: 100 * 1024 * 1024
    validator:
      gt: 0

  internalQueryFacetMaxOutputDocSizeBytes:
    description: "The number of bytes to buffer at once during a $facet stage."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryFacetMaxOutputDocSizeBytes"
    cpp_vartype: AtomicWord<long long>
    default:
      expr: 100 * 1024 * 1024
    validator:
      gt: 0

  internalLookupStageIntermediateDocumentMaxSizeBytes:
    description: "Maximum size of the result set that we cache from the foreign collection during a
    $lookup."
    set_at: [ startup, runtime ]
    cpp_varname: "internalLookupStageIntermediateDocumentMaxSizeBytes"
    cpp_vartype: AtomicWord<long long>
    default:
      expr: 100 * 1024 * 1024
    validator:
      gte: { expr: BSONObjMaxInternalSize}

  internalDocumentSourceGroupMaxMemoryBytes:
    description: "Maximum size of the data that the $group aggregation stage will cache in-memory
    before spilling to disk."
    set_at: [ startup, runtime ]
    cpp_varname: "internalDocumentSourceGroupMaxMemoryBytes"
    cpp_vartype: AtomicWord<long long>
    default:
      expr: 100 * 1024 * 1024
    validator:
      gt: 0

  internalDocumentSourceSetWindowFieldsMaxMemoryBytes:
    description: "Maximum size of the data that the $setWindowFields aggregation stage will cache
    in-memory before throwing an error."
    set_at: [ startup, runtime ]
    cpp_varname: "internalDocumentSourceSetWindowFieldsMaxMemoryBytes"
    cpp_vartype: AtomicWord<long long>
    default:
      expr: 100 * 1024 * 1024
    validator:
      gt: 0

  internalInsertMaxBatchSize:
    description: "Maximum number of documents that we will insert in a single batch."
    set_at: [ startup, runtime ]
    cpp_varname: "internalInsertMaxBatchSize"
    cpp_vartype: AtomicWord<int>
    default:
      expr: 64
      is_constexpr: false
    validator:
      gt: 0

  internalDocumentSourceCursorBatchSizeBytes:
    description: "Maximum amount of data that DocumentSourceCursor will cache from the underlying
    PlanExecutor before pipeline processing."
    set_at: [ startup, runtime ]
    cpp_varname: "internalDocumentSourceCursorBatchSizeBytes"
    cpp_vartype: AtomicWord<int>
    default:
      expr: 4 * 1024 * 1024
    validator:
      gte: 0

  internalDocumentSourceCursorInitialBatchSize:
    description: "The initial number of documents that DocumentSourceCursor will cache from the
    underlying PlanExecutor, the batch size will grow exponentially until reaching
    internalDocumentSourceCursorBatchSizeBytes, A value of 0 means unlimited."
    set_at: [ startup, runtime ]
    cpp_varname: "internalDocumentSourceCursorInitialBatchSize"
    cpp_vartype: AtomicWord<int>
    default: 32
    validator:
      gte: 0

  internalDocumentSourceLookupCacheSizeBytes:
    description: "Maximum amount of non-correlated foreign-collection data that the $lookup stage
    will cache before abandoning the cache and executing the full pipeline on each iteration."
    set_at: [ startup, runtime ]
    cpp_varname: "internalDocumentSourceLookupCacheSizeBytes"
    cpp_vartype: AtomicWord<int>
    default:
      expr: 100 * 1024 * 1024
    validator:
      gte: 0

  internalQueryProhibitBlockingMergeOnMongoS:
    description: "If true, blocking stages such as $group or non-merging $sort will be prohibited
    from running on mongoS."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryProhibitBlockingMergeOnMongoS"
    cpp_vartype: AtomicWord<bool>
    default: false

  internalQueryMaxJsEmitBytes:
    description: "Limits the vector of values emitted from a single document's call to JsEmit to the
        given size in bytes."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryMaxJsEmitBytes"
    cpp_vartype: AtomicWord<int>
    default:
      expr: 100 * 1024 * 1024
    validator:
        gt: 0

  internalQueryMaxPushBytes:
    description: "Limits the vector of values pushed into a single array while grouping with the
    $push accumulator."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryMaxPushBytes"
    cpp_vartype: AtomicWord<int>
    default:
      expr: 100 * 1024 * 1024
    validator:
        gt: 0
    on_update: plan_cache_util::clearSbeCacheOnParameterChange

  internalQueryMaxRangeBytes:
    description: "Limits the vector of values pushed into a single array while generating $range
    result."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryMaxRangeBytes"
    cpp_vartype: AtomicWord<int>
    default:
      expr: 100 * 1024 * 1024
    validator:
        gt: 0

  internalQueryMaxAddToSetBytes:
    description: "Limits the vector of values pushed into a single array while grouping with the
    $addToSet accumulator."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryMaxAddToSetBytes"
    cpp_vartype: AtomicWord<long long>
    default:
      expr: 100 * 1024 * 1024
    validator:
        gt: 0
    on_update: plan_cache_util::clearSbeCacheOnParameterChange

  internalQueryJavaScriptHeapSizeLimitMB:
    description: "Limits the JavaScript heap size used in aggregation. Will defer to the global
    'jsHeapLimitMB' limit if the global limit is smaller."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryJavaScriptHeapSizeLimitMB"
    cpp_vartype: AtomicWord<int>
    default: 100

  internalQueryJavaScriptFnTimeoutMillis:
    description: "Limits the maximum allowed time a user-defined javascript function can run in a
    query."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryJavaScriptFnTimeoutMillis"
    cpp_vartype: AtomicWord<int>
    default:
      expr: 60 * 1000
    validator:
        gt: 0

  internalQueryDesugarWhereToFunction:
    description: "When true, desugars $where to $expr/$function."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryDesugarWhereToFunction"
    cpp_vartype: AtomicWord<bool>
    default: false

  internalQueryDefaultDOP:
    description: "Default degree of parallelism. This an internal experimental parameter and should
    not be changed on live systems."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryDefaultDOP"
    cpp_vartype: AtomicWord<int>
    default: 1
    test_only: true
    validator:
      gt: 0
    on_update: plan_cache_util::clearSbeCacheOnParameterChange

  internalQuerySlotBasedExecutionMaxStaticIndexScanIntervals:
    description: "Limits the number of statically known intervals that SBE can decompose index
    bounds into when possible."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQuerySlotBasedExecutionMaxStaticIndexScanIntervals"
    cpp_vartype: AtomicWord<int>
    default: 1000
    validator:
        gt: 0
    on_update: plan_cache_util::clearSbeCacheOnParameterChange

  internalQueryEnableCSTParser:
    description: "If true, use the grammar-based parser and CST to parse queries."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryEnableCSTParser"
    cpp_vartype: AtomicWord<bool>
    default: false

  internalQueryMaxDocValidationErrorConsideredValues:
    description: "Limits the number of values reported in the 'consideredValues' array when
    generating a descriptive document validation error."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryMaxDocValidationErrorConsideredValues"
    cpp_vartype: AtomicWord<int>
    default: 10
    validator:
        gt: 0

  internalQueryExplainSizeThresholdBytes:
    description: "Number of bytes after which explain should start truncating portions of its
    output."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryExplainSizeThresholdBytes"
    cpp_vartype: AtomicWord<int>
    default:
      expr: 10 * 1024 * 1024
    validator:
        gt: 0
        lte: { expr: BSONObjMaxInternalSize }

  internalQuerySlotBasedExecutionHashAggMemoryUseCheckMargin:
    description: "The memory check in HashAgg stage is done on every T'th processed record, where T
    is calculated adaptively based on the estimated memory used and its recent growth. This setting
    defines the percent of the remaining available memory to be used before the next check, given
    the estimated growth speed per advance [see
    internalQuerySlotBasedExecutionHashAggApproxMemoryUseInBytesBeforeSpill]."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQuerySBEAggMemoryUseCheckMargin"
    cpp_vartype: AtomicDouble
    default: 0.7
    validator:
        gt: 0.0
        lte: 1.0

  internalQuerySlotBasedExecutionHashAggMemoryCheckPerAdvanceAtMost:
    description: "The memory check in HashAgg stage is done on every T'th processed record, where T
    is calculated adaptively based on the estimated memory used and its recent growth. This setting
    defines the lower bound for T [see
    internalQuerySlotBasedExecutionHashAggApproxMemoryUseInBytesBeforeSpill]."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQuerySBEAggMemoryCheckPerAdvanceAtMost"
    cpp_vartype: AtomicWord<long long>
    default: 2
    validator:
        gt: 0

  internalQuerySlotBasedExecutionHashAggMemoryCheckPerAdvanceAtLeast:
    description: "The memory check in HashAgg stage is done on every T'th processed record, where T
    is calculated adaptively based on the estimated memory used and its recent growth. This setting
    defines the upper bound for T. If this setting is less than [see
    internalQuerySlotBasedExecutionHashAggMemoryCheckPerAdvanceAtMost], the check will be done on
    every internalQuerySlotBasedExecutionHashAggMemoryCheckPerAdvanceAtLeast'th processed record
    [see internalQuerySlotBasedExecutionHashAggApproxMemoryUseInBytesBeforeSpill]."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQuerySBEAggMemoryCheckPerAdvanceAtLeast"
    cpp_vartype: AtomicWord<long long>
    default: 1024
    validator:
        gt: 0

  internalQuerySlotBasedExecutionHashAggApproxMemoryUseInBytesBeforeSpill:
    description: "The max size in bytes that the hash table in a HashAgg stage can be estimated to
    be before we spill to disk."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQuerySBEAggApproxMemoryUseInBytesBeforeSpill"
    cpp_vartype: AtomicWord<long long>
    default:
      expr: 100 * 1024 * 1024
    validator:
        gt: 0

  internalQuerySlotBasedExecutionHashAggForceIncreasedSpilling:
    description: "If true, the HashAgg stage will perform increased spilling."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQuerySlotBasedExecutionHashAggForceIncreasedSpilling"
    cpp_vartype: AtomicWord<bool>
    default: false

  internalQuerySlotBasedExecutionHashLookupApproxMemoryUseInBytesBeforeSpill:
    description: "The max size in bytes that the hash table in a HashLookup stage can be estimated to
    be before we spill to disk."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQuerySBELookupApproxMemoryUseInBytesBeforeSpill"
    cpp_vartype: AtomicWord<long long>
    default:
      expr: 100 * 1024 * 1024
    validator:
        gt: 0

  internalQuerySlotBasedExecutionDisableLookupPushdown:
    description: "If true, the system will not push down $lookup to the SBE execution engine."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQuerySlotBasedExecutionDisableLookupPushdown"
    cpp_vartype: AtomicWord<bool>
    default: false
    on_update: plan_cache_util::clearSbeCacheOnParameterChange

  internalQuerySlotBasedExecutionDisableGroupPushdown:
    description: "If true, the system will not push down $group to the SBE execution engine."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQuerySlotBasedExecutionDisableGroupPushdown"
    cpp_vartype: AtomicWord<bool>
    default: false
    on_update: plan_cache_util::clearSbeCacheOnParameterChange

  internalQueryAppendIdToSetWindowFieldsSort:
    description: "If true, appends _id to the sort stage generated by desugaring $setWindowFields to
    ensure deterministic sort order."
    set_at: [startup, runtime]
    cpp_varname: "internalQueryAppendIdToSetWindowFieldsSort"
    cpp_vartype: AtomicWord<bool>
    default: false

  internalQueryTopNAccumulatorBytes:
    description: "Limits the vector of values pushed into a single array while grouping with the 'N'
    family of accumulators."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryTopNAccumulatorBytes"
    cpp_vartype: AtomicWord<int>
    default:
        expr: 100 * 1024 * 1024
    validator:
        gt: 0
    on_update: plan_cache_util::clearSbeCacheOnParameterChange

  enableSearchMeta:
    description: "Exists for backwards compatibility in startup parameters, enabling this was
    required on 4.4 to access SEARCH_META variables. Does not do anything."
    set_at: [ startup, runtime ]
    cpp_varname: "enableSearchMeta"
    cpp_vartype: AtomicWord<bool>
    default: true

  enableTimeoutOfInactiveSessionCursors:
    description: "If true, cursors opened within sessions are eligible for inactive cursor timeout."
    set_at: [ startup, runtime ]
    cpp_varname: "enableTimeoutOfInactiveSessionCursors"
    cpp_vartype: AtomicWord<bool>
    default: false

  internalQueryMaxAllowedDensifyDocs:
    description: "Limits the number of documents that $densify is allowed to generate."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryMaxAllowedDensifyDocs"
    cpp_vartype: AtomicWord<int>
    default:  500000
    validator:
        gt: 0

  internalDocumentSourceDensifyMaxMemoryBytes:
    description: "Limits the number of bytes densification can use to store partition information."
    set_at: [ startup, runtime ]
    cpp_varname: "internalDocumentSourceDensifyMaxMemoryBytes"
    cpp_vartype: AtomicWord<int>
    default:
        expr: 100 * 1024 * 1024
    validator:
        gt: 0

  internalQueryCardinalityEstimatorMode:
    description: "Set to select a method for estimating cardinality in the Cascades optimizer."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryCardinalityEstimatorMode"
    cpp_vartype: std::string
    default: heuristic
    validator:
        callback: optimizer::ce::validateCEMode
    on_update: plan_cache_util::clearSbeCacheOnParameterChange

  internalCascadesOptimizerDisableScan:
    description: "Disable full collection scans in the Cascades optimizer."
    set_at: [ startup, runtime ]
    cpp_varname: "internalCascadesOptimizerDisableScan"
    cpp_vartype: AtomicWord<bool>
    default: false
    on_update: plan_cache_util::clearSbeCacheOnParameterChange

  internalCascadesOptimizerDisableIndexes:
    description: "Disable index scan plans in the Cascades optimizer."
    set_at: [ startup, runtime ]
    cpp_varname: "internalCascadesOptimizerDisableIndexes"
    cpp_vartype: AtomicWord<bool>
    default: false
    on_update: plan_cache_util::clearSbeCacheOnParameterChange

  internalCascadesOptimizerDisableMergeJoinRIDIntersect:
    description: "Disable index RID intersection via merge join in the Cascades optimizer."
    set_at: [ startup, runtime ]
    cpp_varname: "internalCascadesOptimizerDisableMergeJoinRIDIntersect"
    cpp_vartype: AtomicWord<bool>
    default: false
    on_update: plan_cache_util::clearSbeCacheOnParameterChange

  internalCascadesOptimizerDisableHashJoinRIDIntersect:
    description: "Disable index RID intersection via hash join in the Cascades optimizer."
    set_at: [ startup, runtime ]
    cpp_varname: "internalCascadesOptimizerDisableHashJoinRIDIntersect"
    cpp_vartype: AtomicWord<bool>
    default: false
    on_update: plan_cache_util::clearSbeCacheOnParameterChange

  internalCascadesOptimizerDisableGroupByAndUnionRIDIntersect:
    description: "Disable index RID intersection via group by and union in the Cascades optimizer."
    set_at: [ startup, runtime ]
    cpp_varname: "internalCascadesOptimizerDisableGroupByAndUnionRIDIntersect"
    cpp_vartype: AtomicWord<bool>
    default: false
    on_update: plan_cache_util::clearSbeCacheOnParameterChange

  internalCascadesOptimizerKeepRejectedPlans:
    description: "Keep track of rejected plans in the memo. Applies only to the Cascades optimizer."
    set_at: [ startup, runtime ]
    cpp_varname: "internalCascadesOptimizerKeepRejectedPlans"
    cpp_vartype: AtomicWord<bool>
    default: false
    test_only: true

  internalCascadesOptimizerDisableBranchAndBound:
    description: "Disable cascades branch-and-bound strategy, and fully evaluate all plans in the
    Cascades optimizer."
    set_at: [ startup, runtime ]
    cpp_varname: "internalCascadesOptimizerDisableBranchAndBound"
    cpp_vartype: AtomicWord<bool>
    default: false
    test_only: true

  internalCascadesOptimizerDisableSargableWhenNoIndexes:
    description: "Disable sargable rewrites when there are no indexes."
    set_at: [ startup, runtime ]
    cpp_varname: "internalCascadesOptimizerDisableSargableWhenNoIndexes"
    cpp_vartype: AtomicWord<bool>
    default: true
    on_update: plan_cache_util::clearSbeCacheOnParameterChange

  internalCascadesOptimizerFastIndexNullHandling:
    description: "Controls if we prefer to cover queries which may return nulls with indexes."
    set_at: [ startup, runtime ]
    cpp_varname: "internalCascadesOptimizerFastIndexNullHandling"
    cpp_vartype: AtomicWord<bool>
    default: false
    on_update: plan_cache_util::clearSbeCacheOnParameterChange

  internalCascadesOptimizerSampleChunks:
    description: "Controls the number of chunks to sample for CE."
    set_at: [ startup, runtime ]
    cpp_varname: "internalCascadesOptimizerSampleChunks"
    cpp_vartype: AtomicWord<int>
    default: 10
    validator:
      gte: 0

  internalCascadesOptimizerRepeatableSample:
    description: "Draws a sample once per query and reuses it for estimating multiple predicates. Only takes effect if 'internalCascadesOptimizerSampleChunks > 0'."
    set_at: [ startup, runtime ]
    cpp_varname: "internalCascadesOptimizerRepeatableSample"
    cpp_vartype: AtomicWord<bool>
    default: true

  internalCascadesOptimizerSampleSizeMin:
    description: "Controls the minimum collection size to use sampling for CE."
    set_at: [ startup, runtime ]
    cpp_varname: "internalCascadesOptimizerSampleSizeMin"
    cpp_vartype: AtomicWord<int>
    default: 100
    validator:
      gte: 1

  internalCascadesOptimizerSampleSizeMax:
    description: "Controls the maximum collection size to use sampling for CE."
    set_at: [ startup, runtime ]
    cpp_varname: "internalCascadesOptimizerSampleSizeMax"
    cpp_vartype: AtomicWord<int>
    default: 10000
    validator:
      gte: 1

  internalCascadesOptimizerSampleIndexedFields:
    description: "Controls whether to only sample indexed fields for CE."
    set_at: [ startup, runtime ]
    cpp_varname: "internalCascadesOptimizerSampleIndexedFields"
    cpp_vartype: AtomicWord<bool>
    default: true

  internalCascadesOptimizerSampleTwoFields:
    description: "Controls whether to sample the two most frequent fields together."
    set_at: [ startup, runtime ]
    cpp_varname: "internalCascadesOptimizerSampleTwoFields"
    cpp_vartype: AtomicWord<bool>
    default: true

  internalCascadesOptimizerEnableSqrtSampleSize:
    description: "Use sqrt(numDocs) for sample size when enabled, otherwise numDocs."
    set_at: [ startup, runtime ]
    cpp_varname: "internalCascadesOptimizerEnableSqrtSampleSize"
    cpp_vartype: AtomicWord<bool>
    default: true

  internalCascadesOptimizerDisableYieldingTolerantPlans:
    description: "Controls if we prefer to insert redundant index predicates on the Seek side in order to prevent issues arising from yielding."
    set_at: [ startup, runtime ]
    cpp_varname: "internalCascadesOptimizerDisableYieldingTolerantPlans"
    cpp_vartype: AtomicWord<bool>
    default: true

  internalCascadesOptimizerMinIndexEqPrefixes:
    description: "Controls the minimum number of equality prefixes in each candidate index."
    set_at: [ startup, runtime ]
    cpp_varname: "internalCascadesOptimizerMinIndexEqPrefixes"
    cpp_vartype: AtomicWord<int>
    default: 1
    on_update: plan_cache_util::clearSbeCacheOnParameterChange

  internalCascadesOptimizerMaxIndexEqPrefixes:
    description: "Controls the maximum number of equality prefixes in each candidate index."
    set_at: [ startup, runtime ]
    cpp_varname: "internalCascadesOptimizerMaxIndexEqPrefixes"
    cpp_vartype: AtomicWord<int>
    default: 1
    on_update: plan_cache_util::clearSbeCacheOnParameterChange

  internalCascadesOptimizerStdCoutDebugOutput:
    description: "Enables verbose, non-JSON, debug output for Cascades optimizer."
    set_at: [ startup, runtime ]
    cpp_varname: "internalCascadesOptimizerStdCoutDebugOutput"
    cpp_vartype: AtomicWord<bool>
    default: false
    test_only: true

  internalCascadesOptimizerExplainVersion:
    description: "Selects the explain version of the plans from the Cascades optimizer. The default is 'bson', other supported versions are 'v1', 'v2', and 'v2compact'"
    set_at: [ startup, runtime ]
    cpp_varname: "internalCascadesOptimizerExplainVersion"
    cpp_vartype: synchronized_value<std::string>
    default: "bson"
    validator:
        callback: optimizer::validateOptimizerExplainVersion
    test_only: true

  internalCascadesOptimizerUseDescriptiveVarNames:
    description: "Enables generation of descriptive variable names to aid debugging."
    set_at: [ startup, runtime ]
    cpp_varname: "internalCascadesOptimizerUseDescriptiveVarNames"
    cpp_vartype: AtomicWord<bool>
    default: false
    test_only: true

  internalCascadesOptimizerSamplingCEScanStartOfColl:
    description: "Forces sampling CE to select sample by scanning from the start of the collection."
    set_at: [ startup, runtime ]
    cpp_varname: "internalCascadesOptimizerSamplingCEScanStartOfColl"
    cpp_vartype: AtomicWord<bool>
    default: false
    test_only: true

  internalCascadesOptimizerEnableNotPushdown:
    description: "Enables the NotPushdown optimization which attempts to remove Not nodes by pushing them down towards the leaves."
    set_at: [ startup, runtime ]
    cpp_varname: "internalCascadesOptimizerEnableNotPushdown"
    cpp_vartype: AtomicWord<bool>
    default: false
    on_update: plan_cache_util::clearSbeCacheOnParameterChange

  internalCascadesOptimizerSamplingCEFallBackForFilterNode:
    description: "Forces sampling CE to fall back on heuristic for filter node."
    set_at: [ startup, runtime ]
    cpp_varname: "internalCascadesOptimizerSamplingCEFallBackForFilterNode"
    cpp_vartype: AtomicWord<bool>
    default: true

  internalCascadesOptimizerDisableFastPath:
    description: "Disables fast paths that shortcut the optimizer for some trivial queries."
    set_at: [ startup, runtime ]
    cpp_varname: "internalCascadesOptimizerDisableFastPath"
    cpp_vartype: AtomicWord<bool>
    default: false

  internalCascadesOptimizerEnableParameterization:
    description: "Enables query parameterization of constants."
    set_at: [ startup, runtime ]
    cpp_varname: "internalCascadesOptimizerEnableParameterization"
    cpp_vartype: AtomicWord<bool>
    default: true
    on_update: plan_cache_util::clearSbeCacheOnParameterChange

  internalQueryFrameworkControl:
    description: "Knob to control the optimizer/execution engine to use."
    set_at: [ startup, runtime ]
    cpp_class:
      name: QueryFrameworkControl
      data: synchronized_value<QueryFrameworkControlEnum>
    default:
      expr: QueryFrameworkControlEnum::kTrySbeRestricted

  internalQueryDisableSingleFieldExpressExecutor:
    description: "Knob to control whether single-field equalities (other than IDHACK) can use the express executor."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryDisableSingleFieldExpressExecutor"
    cpp_vartype: AtomicWord<bool>
    default: false

  internalQueryCollectionMaxNoOfDocumentsToChooseHashJoin:
    description: "Up to what number of documents do we choose the hash join algorithm when $lookup
    is translated to a SBE plan."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryCollectionMaxNoOfDocumentsToChooseHashJoin"
    cpp_vartype: AtomicWord<long long>
    default:
      expr: 10 * 1000
    validator:
        gt: 0
    on_update: plan_cache_util::clearSbeCacheOnParameterChange

  internalQueryCollectionMaxDataSizeBytesToChooseHashJoin:
    description: "Up to what data size do we choose the hash join algorithm when $lookup
    is translated to a SBE plan."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryCollectionMaxDataSizeBytesToChooseHashJoin"
    cpp_vartype: AtomicWord<long long>
    default:
        expr: 100 * 1024 * 1024
    validator:
        gt: 0
    on_update: plan_cache_util::clearSbeCacheOnParameterChange

  internalQueryCollectionMaxStorageSizeBytesToChooseHashJoin:
    description: "Up to what storage size do we choose the hash join algorithm when $lookup
    is translated to a SBE plan."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryCollectionMaxStorageSizeBytesToChooseHashJoin"
    cpp_vartype: AtomicWord<long long>
    default:
        expr: 100 * 1024 * 1024
    validator:
        gt: 0
    on_update: plan_cache_util::clearSbeCacheOnParameterChange

  internalQueryDisableLookupExecutionUsingHashJoin:
    description: "Disable lookup execution using hash join algorithm, this will cause the plans,
    eligible for the hash join strategy, to fall back to using the nested loop join strategy."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryDisableLookupExecutionUsingHashJoin"
    cpp_vartype: AtomicWord<bool>
    default: false
    on_update: plan_cache_util::clearSbeCacheOnParameterChange

  internalQueryMaxNumberOfFieldsToChooseUnfilteredColumnScan:
    description: "Up to what number of fields do we choose to use the column store index when there
    are no other indexed alternatives and no query predicates that can be applied during the column
    store index scan? Set to 0 to never use the column store, even if there is only one referenced
    field."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryMaxNumberOfFieldsToChooseUnfilteredColumnScan"
    cpp_vartype: AtomicWord<int>
    default: 5
    validator:
        gte: 0
    on_update: plan_cache_util::clearSbeCacheOnParameterChange

  internalQueryMaxNumberOfFieldsToChooseFilteredColumnScan:
    description: "Up to what number of fields do we choose to use the column store index when there
    are no other indexed alternatives but at least one query predicate that can be applied during
    the column store index scan? Set to 0 to never use the column store, even if there is only one
    referenced field."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryMaxNumberOfFieldsToChooseFilteredColumnScan"
    cpp_vartype: AtomicWord<int>
    default: 12
    validator:
        gte: 0
    on_update: plan_cache_util::clearSbeCacheOnParameterChange

  internalQueryFLERewriteMemoryLimit:
    description: "Maximum memory available for encrypted field query rewrites in bytes. Must be
    more than zero and less than 16Mb"
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryFLERewriteMemoryLimit"
    cpp_vartype: AtomicWord<int>
    default:
        expr: 14 * 1024 * 1024
    validator:
        gt: 0
        lt: 16777216

  internalMeasureQueryExecutionTimeInNanoseconds:
    description: "If true, the explain results include 'executionTimeMicros' and
    'executionTimeNanos' fields to represent the execution time of each SBE plan stage in
    microseconds and in nanoseconds"
    set_at: [ startup ]
    cpp_varname: "internalMeasureQueryExecutionTimeInNanoseconds"
    cpp_vartype: AtomicWord<bool>
    default: false

  internalQueryFLEAlwaysUseEncryptedCollScanMode:
    description: "Boolean flag to force FLE to always use low selectivity mode"
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryFLEAlwaysUseEncryptedCollScanMode"
    cpp_vartype: AtomicWord<bool>
    default:
        expr: false

  internalCostModelCoefficients:
    description: "Cost Model Coefficients Override"
    set_at: [ startup, runtime ]
    cpp_varname: "internalCostModelCoefficients"
    cpp_vartype: synchronized_value<std::string>
    on_update: cost_model::updateCostCoefficientsOnUpdate

  # TODO SERVER-68341 Remove this query knob after tenancy is supported in the sharded cluster.
  internalChangeStreamUseTenantIdForTesting:
    description: "If true, then change streams will operate upon an internal tenant id for testing
                  purposes if the actual tenant is not provided."
    set_at: [ startup ]
    cpp_varname: "internalChangeStreamUseTenantIdForTesting"
    cpp_vartype: AtomicWord<bool>
    default: false

  enableComputeMode:
    description: "Boolean flag to enable the compute mode in which mongod is used not as a
      persistent storage node, but as a worker node for executing queries."
    set_at: [ startup ]
    cpp_varname: "computeModeEnabled"
    cpp_vartype: bool
    default: false

  externalPipeDir:
    description: "Absolute path to the directory where external named pipes can be found. The
      trailing '/' must be included."
    set_at: [ startup ]
    cpp_varname: "externalPipeDir"
    cpp_vartype: std::string

  internalQueryDisableExclusionProjectionFastPath:
    description: "If true, then ExclusionProjectionExecutor won't use fast path implementation. This
    is needed for the generational fuzzers that are sensitive to field order and other corner cases
    when switching from Document to BSONObj."
    set_at: [ startup ]
    cpp_varname: "internalQueryDisableExclusionProjectionFastPath"
    cpp_vartype: bool
    default: false
    test_only: true

  internalQueryStatsRateLimit:
    description: "The maximum number of queries per second that are sampled for query stats.
      If the rate of queries goes above this number, then rate limiting will kick in, and any
      further queries will not be sampled. To sample all queries, this can be set to -1. This can be
      set to 0 to turn queryStats off completely."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryStatsRateLimit"
    cpp_vartype: AtomicWord<int>
    default: 0
    validator:
      gte: -1
    on_update: query_stats_util::onQueryStatsSamplingRateUpdate

  internalQueryStatsCacheSize:
    description: "The maximum amount of memory that the system will allocate for the query queryStats
      cache. This will accept values in either of the following formats:
      1. <number>% indicates a percentage of the physical memory available to the process. E.g.: 15%.
      2. <number>(MB|GB), indicates the amount of memory in MB or GB. E.g.: 1.5GB, 100MB.
      The default value is 1%, which means 1% of the physical memory available to the process."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryStatsCacheSize"
    cpp_vartype: synchronized_value<std::string>
    default: "1%"
    on_update: query_stats_util::onQueryStatsStoreSizeUpdate
    validator:
      callback: query_stats_util::validateQueryStatsStoreSize

  internalQueryStatsErrorsAreCommandFatal:
    description: "Whether errors in the $queryStats stage cause the aggregation pipeline to
      immediately fail and report the error. Note that this is always the case for debug builds."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryStatsErrorsAreCommandFatal"
    cpp_vartype: AtomicWord<bool>
    default: false

  internalQueryColumnScanMinCollectionSizeBytes:
    description: "The min collection size threshold for which column scan will always be allowed. If
      the value is -1, decision will be made based on the size of available memory. If it is set to
      0 column scan will always be allowed."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryColumnScanMinCollectionSizeBytes"
    cpp_vartype: AtomicWord<long long>
    default: -1
    validator:
      gte: -1
    on_update: plan_cache_util::clearSbeCacheOnParameterChange

  internalQueryColumnScanMinAvgDocSizeBytes:
    description: "The min average document size threshold for which column scan will always be
      allowed. If it is set to 0 column scan will always be allowed."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryColumnScanMinAvgDocSizeBytes"
    cpp_vartype: AtomicWord<long long>
    default: 1024
    validator:
      gte: 0
    on_update: plan_cache_util::clearSbeCacheOnParameterChange

  internalQueryColumnRowstoreScanMinBatchSize:
    description: "The minimum number of records that will be scanned from the row store after
    running into a record that cannot be served from the index and before attempting to use the
    index again. No preemptive scanning will be done if this setting is 0."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryColumnRowstoreScanMinBatchSize"
    cpp_vartype: AtomicWord<long long>
    # The preemptive scan of the row store mitigates the situation when there is a range of records
    # that cannot be served from CSI. We increase the batch size exponentially as we keep seeing
    # 'bad' data so starting with a low minimum batch size is OK and allows to minimize scanning
    # if the 'bad' records are isolated.
    default: 1
    validator:
        gte: 0

  internalQueryColumnRowstoreScanMaxBatchSize:
    description: "The maximum number of records that can be scanned from the row store after
    running into a record that cannot be served from the index and before attempting to use the
    index again. If this setting is less than 'internalQueryColumnRowstoreScanMinBatchSize' the
    batch size will be fixed at 'internalQueryColumnRowstoreScanMinBatchSize'."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryColumnRowstoreScanMaxBatchSize"
    cpp_vartype: AtomicWord<long long>
    # The sweet spot for scanning vs attempting to use the index would very much depend on the data
    # so there is no default setting that would work in all situations. Setting it relatively high
    # favors the case when all of the data would require reading from the row store.
    default: 10000
    validator:
        gte: 0

  internalQueryColumnScanMinNumColumnFilters:
    description: "The min number of column filters for which column scan will always be allowed. If
      it is set to 0 column scan will always be allowed."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryColumnScanMinNumColumnFilters"
    cpp_vartype: AtomicWord<int>
    default: 3
    validator:
      gte: 0
    on_update: plan_cache_util::clearSbeCacheOnParameterChange

  internalQueryCutoffForSampleFromRandomCursor:
    description: "The maximum sample ratio for random cursor."
    set_at: cluster
    cpp_varname: "internalQueryCutoffForSampleFromRandomCursor"
    cpp_vartype: InternalQueryCutoffForSampleFromRandomCursorStorage

  internalQueryGlobalProfilingFilter:
    description: "Enables the setProfilingFilterGlobally command."
    set_at: [ startup ]
    cpp_varname: internalQueryGlobalProfilingFilter
    cpp_vartype: AtomicWord<bool>
    default: false

  internalQueryAggMulticastTimeoutMS:
    description: "Timeout in MS for requests to shard servers when aggregations are sent to all shard servers"
    set_at: [ startup ]
    cpp_vartype: int
    cpp_varname: internalQueryAggMulticastTimeoutMS
    default: 60000
    validator:
      gte: 0

  internalQueryAggMulticastMaxConcurrency:
    description: "Max number of concurrent requests when aggregations are sent to all shard servers"
    set_at: startup
    cpp_vartype: int
    cpp_varname: internalQueryAggMulticastMaxConcurrency
    default: 100
    validator:
      gte: 1

  enableAccessToUserRoles:
    description: "Enables access to $$USER_ROLES in queries."
    set_at: [ startup, runtime ]
    cpp_varname: enableAccessToUserRoles
    cpp_vartype: AtomicWord<bool>
    default: true

  internalQueryTdigestDelta:
    description: "Compaction parameter the for t-digest algorithm. Increasing delta might improve
     accuracy of the computed percentiles at the cost of using more memory (about 12KB per 1000 of
     increase). Runtime of t-digest also depends on delta but non-linearly. The current default was
     chosen empirically to yield good balance between runtime, memory consumption and accuracy on
     most datasets."
    set_at: [ startup, runtime ]
    cpp_varname: internalQueryTdigestDelta
    cpp_vartype: AtomicWord<int>
    default: 2000
    validator:
      gte: 0
      lte: 100000 # arbitrary, just to set an upper limit on the amount of memory used by t-digest

  internalQueryPercentileExprSelectToSortThreshold:
    description: "The discrete percentile algorithm uses selection from unsorted data to find a
     single percentile and sorts the data when sufficiently many percentiles are requested as once.
     The threshold has been determined empirically from benchmarks."
    set_at: [ startup, runtime ]
    cpp_varname: internalQueryPercentileExprSelectToSortThreshold
    cpp_vartype: AtomicWord<int>
    default: 20
    validator:
      gte: 0

  internalQueryAutoParameterizationMaxParameterCount:
    description: "The maximum numbers of parameters that query auto-parameterization can extract from a query.
     If auto parameterizating a query would result in a greater number of parameters than the limit,
     then auto parameterization will not be performed.
     If set to 0, then no limit will be applied."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryAutoParameterizationMaxParameterCount"
    cpp_vartype: AtomicWord<int>
    default: 512
    validator:
      gte: 0
    on_update: plan_cache_util::clearSbeCacheOnParameterChange

  internalQueryEnableBooleanExpressionsSimplifier:
    description: "Boolean expression simplifier converts filter expression into Disjunctive Normal
     Form and applies some simplifications."
    set_at: [ startup, runtime ]
    cpp_varname: internalQueryEnableBooleanExpressionsSimplifier
    cpp_vartype: AtomicWord<bool>
    default: true

  internalQueryMaximumNumberOfUniquePredicatesToSimplify:
    description: "If the number of unique predicates in an expression is larger than
     'maximumNumberOfUniquePredicates' the expression is considered too big to be simplified."
    set_at: [ startup, runtime ]
    cpp_varname: internalQueryMaximumNumberOfUniquePredicatesToSimplify
    cpp_vartype: AtomicWord<int>
    default: 64

  internalQueryMaximumNumberOfMintermsInSimplifier:
    description: "Maximum number of minterms allowed during boolean transformations."
    set_at: [ startup, runtime ]
    cpp_varname: internalQueryMaximumNumberOfMintermsInSimplifier
    cpp_vartype: AtomicWord<int>
    default: 1000

  internalQueryMaxSizeFactorToSimplify:
    description: "If the simplified expression is larger than the original expression's size times
      `internalQueryMaxSizeFactorToSimplify`, the simplified one will be rejected."
    set_at: [ startup, runtime ]
    cpp_varname: internalQueryMaxSizeFactorToSimplify
    cpp_vartype: AtomicDouble
    default: 1.0

  internalQueryDoNotOpenContainedOrsInSimplifier:
    description: "If the original expression contains AND operator it is still simplified but the
     common predicate of the simplified conjunctive terms are taken out of brackets."
    set_at: [ startup, runtime ]
    cpp_varname: internalQueryDoNotOpenContainedOrsInSimplifier
    cpp_vartype: AtomicWord<bool>
    default: true

  internalQueryMaxSpoolMemoryUsageBytes:
    description: "The maximum amount of memory a query or command is willing to use to execute a
      spool, measured in bytes. If disk use is allowed, then it may be possible to spool more data,
      but this limit will still constrain the memory consumption."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryMaxSpoolMemoryUsageBytes"
    cpp_vartype: AtomicWord<long long>
    default:
      expr: 100 * 1024 * 1024
    validator:
      gt: 0

  internalQueryMaxSpoolDiskUsageBytes:
    description: "The maximum amount of disk a query or command is willing to use to execute a
      spool, measured in bytes."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQueryMaxSpoolDiskUsageBytes"
    cpp_vartype: AtomicWord<long long>
    default:
      expr: 10 * 100 * 1024 * 1024
    validator:
      gt: 0

  deprioritizeUnboundedUserCollectionScans:
   description: "Unbounded user collection scans are executed with low storage admission priority"
   set_at: [ startup, runtime ]
   cpp_varname: gDeprioritizeUnboundedUserCollectionScans
   cpp_vartype: AtomicWord<bool>
   default: true

  deprioritizeUnboundedUserIndexScans:
   description: "Unbounded user index scans are executed with low storage admission priority"
   set_at: [ startup, runtime ]
   cpp_varname: gDeprioritizeUnboundedUserIndexScans
   cpp_vartype: AtomicWord<bool>
   default: true

  internalQueryDocumentSourceWriterBatchExtraReservedBytes:
    description: "Space to reserve in document source writer batches for miscellaneous metadata"
    set_at: [ startup, runtime ]
    cpp_vartype: AtomicWord<int>
    cpp_varname: internalQueryDocumentSourceWriterBatchExtraReservedBytes
    validator:
      gte: 0
      lte:
        expr: 8 * 1024 * 1024 # 8MB
    default: 0

  internalQuerySlotBasedExecutionWindowBufferMemorySamplingAtLeast:
    description: "The window buffer memory sampling in the window stage is performed in an exponential
    backoff way on the processed records. This setting defines the least sampling frequency."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQuerySlotBasedExecutionWindowBufferMemorySamplingAtLeast"
    cpp_vartype: AtomicWord<long long>
    default: 1024
    validator:
        gt: 0

  internalQuerySlotBasedExecutionWindowStateMemorySamplingAtLeast:
    description: "The window state memory sampling in the window stage is performed in an exponential
    backoff way for different window frame size. This setting defines the least sampling frequency."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQuerySlotBasedExecutionWindowStateMemorySamplingAtLeast"
    cpp_vartype: AtomicWord<long long>
    default: 1024
    validator:
        gt: 0

  internalQuerySlotBasedExecutionDisableTimeSeriesPushdown:
    description: "If true, the system will not push down time-series queries to the SBE execution engine."
    set_at: [ startup, runtime ]
    cpp_varname: "internalQuerySlotBasedExecutionDisableTimeSeriesPushdown"
    cpp_vartype: AtomicWord<bool>
    default: false
    on_update: plan_cache_util::clearSbeCacheOnParameterChange

  internalQuerySpillingMaxWaitTimeout:
    description: "Timeout in MS that the storage engine will block a spilling operation when the
      cache is under pressure."
    set_at: [ startup, runtime ]
    cpp_vartype: AtomicWord<int>
    cpp_varname: internalQuerySpillingMaxWaitTimeout
    default: 1000
    validator:
      gte: 0

  internalQueryCollectOptimizerMetrics:
   description: "If true, collect query optimizer metrics in queryStats."
   set_at: [ startup, runtime ]
   cpp_varname:  internalQueryCollectOptimizerMetrics
   cpp_vartype: AtomicWord<bool>
   default: false

# Note for adding additional query knobs:
#
# When adding a new query knob, you should consider whether or not you need to add an 'on_update'
# hook to flush the SBE plan cache. If your knob affects the contents of SBE plans which may be
# cached, then the SBE cache should be flushed when the value of the knob changes. This will ensure
# that the application actually starts to get plans which reflect the new value of the knob, rather
# than continuing to use stale cached plans.
#
# When adding a new query knob which flushes the SBE plan cache on update, you should test this
# behavior by including the name of the new knob in the list at the top of the jstest
# 'sbe_plan_cache_clear_on_param_change.js'.
#
# When adding a new runtime query knob, consider adding and accessing it through the
# 'QueryKnobConfiguration' decoration, especially if it may be accessed multiple times during a
# query lifetime.
