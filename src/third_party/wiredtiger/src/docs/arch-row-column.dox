/*! @arch_page arch-row-column Row Store and Column Store

@section row_column_definition Definition

WiredTiger supports both row-stores and column-stores and each access method is represented
internally by a B-Tree. Keys and values in row-stores can be of variable length. Furthermore, keys
are explicitly stored. Column-stores use a 64-bit unsigned integer record id as keys and they are
implied given the row's position in the B-Tree.

Please refer to @ref arch-data-file "Data File Format" to learn more about the on-disk format for
row-stores and column-stores.

@section row_column_rs Row-stores

Row-stores are probably seen as the traditional access method and they serve a general purpose. In
WiredTiger, row-store keys are explicitly stored and they can be duplicated within the same single
file which directly impacts the on-disk storage size. However, keys are only duplicated if they are
the first key on the page, which gets them copied/promoted to an internal page. They are not
necessarily duplicated, too, they can be prefix/suffix compressed to discard unnecessary bytes on
the internal pages.

@section row_column_vlcs Variable length column-stores

Keys in column-stores are not stored but derived from the row's position in the B-Tree which saves
disk space. In fact, there is a starting key on each page which is used to figure out the rest of
the keys present on that same page. Column-stores values also present an advantage to further save
more disk space as they can be written in more compact forms through encoding techniques. In
WiredTiger, the run-length encoding is used to replace any sequence of the same value with a count
and value indicator. However, this makes the access to a specific record more complicated, it makes
it impossible to jump to a record in a leaf page.

@section row_column_internal_use Internal usage

Internally, row-stores and column-stores use a common \c WT_BTREE structure. The fundamental
difference is that the \c WT_BTREE->type field is set to \c BTREE_ROW for row-stores and
\c BTREE_COL for column-stores. Internal functions that navigate, access and manipulate B-Trees have
code sprinkled throughout that is conditional on \c WT_BTREE->type.

<table>
@hrow{, Row Store, Column Store - Variable Length}
@row{Characteristics,,,,}
@row{Internal representation, B-Tree (\c WT_BTREE), B-Tree (\c WT_BTREE)}
@row{B-Tree type, Generalized (\c BTREE_ROW), Specialized (\c BTREE_COL_VAR)}
@row{Leaf pages, Key count equal to half the number of physical entries (unless all empty values flag is set where key count is equal to the number of physical entries), Only the first key is stored}
@row{Record key, Anything (byte-string) prefix compressed or overflow objects, Record id (64 bit unsigned integer)}
@row{Record value, Variable byte string length, Variable byte string length}
@row{Features,,,}
@row{Random cursor, Yes, No}
@row{Block compression, Yes, Yes}
@row{Dictionary compression, Yes, Yes}
@row{Fast truncate, Yes, No}
@row{Prefix and suffix compression, Yes, No}
@row{RLE compression, No, Yes}
</table>

*/
